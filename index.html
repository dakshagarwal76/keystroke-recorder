<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Keystroke Sound Recorder (WAV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f5f7fa;
      display: flex;
      justify-content: center;
      align-items: start;
      min-height: 100vh;
      margin: 0;
      padding: 24px;
      color: #222;
    }
    .container {
      background: #ffffff;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      width: 100%;
      max-width: 900px;
    }
    h1 {
      font-size: 1.8em;
      color: #333;
      margin: 0 0 6px 0;
    }
    h2 {
      margin: 24px 0 8px;
      font-size: 1.2em;
      color: #333;
    }
    p {
      font-size: 0.98em;
      color: #555;
      margin: 0 0 14px 0;
      line-height: 1.5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    label {
      font-size: 0.92em;
      color: #333;
      display: block;
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      font-size: 1em;
      border: 2px solid #ddd;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      transition: border-color 0.2s;
      background: #fff;
    }
    input:disabled, select:disabled {
      background: #f0f0f0;
      color: #666;
      cursor: not-allowed;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4a90e2;
    }
    textarea {
      width: 100%;
      padding: 14px;
      font-size: 1.05em;
      border: 2px solid #ddd;
      border-radius: 8px;
      resize: vertical;
      min-height: 160px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      transition: border-color 0.2s;
      background: #fff;
    }
    .btn {
      background-color: #4a90e2;
      color: #fff;
      border: none;
      padding: 10px 18px;
      font-size: 0.98em;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .btn:hover { background-color: #357ab8; }
    .btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .btn.secondary {
      background-color: #6b7280;
    }
    .btn.secondary:hover { background-color: #4b5563; }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .muted {
      color: #666;
      font-size: 0.9em;
    }
    .status {
      margin-top: 12px;
      font-size: 0.95em;
      color: #444;
      min-height: 24px;
    }
    .pressed-keys {
      margin-top: 10px;
      font-size: 0.95em;
      color: #222;
      word-wrap: break-word;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
      color: #1f2937;
    }
    .consent {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 10px 0 4px;
    }
    .note {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      color: #7c2d12;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 0.95em;
    }
    .info-badge {
      display: inline-block;
      background: #e0f2fe;
      color: #0369a1;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.9em;
      margin-top: 8px;
    }
    .sep { height: 1px; background: #e5e7eb; margin: 18px 0; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Keystroke Sound Recorder</h1>
    <p class="muted">
      This page records short audio snippets around each key press while you type a standardized paragraph.
    </p>

    <div class="note">
      Grant microphone access when prompted. Keep your environment quiet to reduce background noise.
    </div>

    <h2>Device Information</h2>
    <div class="grid">
      <div>
        <label for="deviceIdDisplay">Device ID</label>
        <input id="deviceIdDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="osDisplay">Operating System</label>
        <input id="osDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="browserDisplay">Browser</label>
        <input id="browserDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="deviceTypeDisplay">Device Type</label>
        <input id="deviceTypeDisplay" type="text" readonly disabled />
      </div>
    </div>

    <h2>Participant Details</h2>
    <div class="grid">
      <div>
        <label for="pid">Participant ID</label>
        <input id="pid" type="text" readonly disabled />
      </div>
      <div>
        <label for="session">Session Number</label>
        <input id="session" type="number" min="1" value="1" readonly disabled />
        <span class="info-badge" id="sessionInfo">Auto-detected</span>
      </div>
      <div>
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="">Select</option>
          <option>Female</option>
          <option>Male</option>
          <option>Other</option>
          <option>Prefer not to say</option>
        </select>
      </div>
      <div>
        <label for="hand">Handedness</label>
        <select id="hand">
          <option value="">Select</option>
          <option>Left</option>
          <option>Right</option>
          <option>Ambidextrous</option>
        </select>
      </div>
    </div>

    <div class="consent">
      <input type="checkbox" id="consentChk" />
      <label for="consentChk">I consent to participate in this research recording.</label>
    </div>

    <div class="sep"></div>

    <h2>Paragraph to Type</h2>
    <p class="muted">Type the paragraph below exactly as shown.</p>

    <pre>The quick brown fox jumps over the lazy dog while amazing zebras quietly vex jumpy kids, proving every letter is present. Pack my box with five dozen liquor jugs to verify the alphabet twice.
Digits appear forward and backward: 1234567890 then 0987654321, followed by sequences like 2468, 13579, and 314159.
Now we add punctuation: . , ; : ? ! ' " - _ ( ) [ ] { } / \
Symbols and operators: @ # $ % ^ & * + = &lt; &gt; | ~
To include uppercase properly, acronyms like NASA, USA, UN, AI, ML, and HTML are written in full caps.
Typing speed and accuracy will be measured across every key, ensuring consistency of captured events.
Finally, we conclude with a mix: The year is 2025; version v1.0-beta includes features [alpha], {bravo}, and (charlie), all typed carefully for complete coverage of the QWERTY keyboard.</pre>

    <h2>Typing Box</h2>
    <textarea id="inputArea" rows="8" placeholder="Start typing after clicking 'Start Recording'" disabled></textarea>

    <div class="button-row">
      <button class="btn" id="startBtn">Start Recording</button>
      <button class="btn" id="stopBtn" disabled>Stop Recording</button>
    </div>

    <div class="status" id="status">Loading...</div>
    <div class="pressed-keys">
      <strong>Keys Pressed:</strong> <span id="keyList"></span>
    </div>

    <footer style="margin-top: 40px; padding-top: 12px; border-top: 1px solid #e5e7eb; text-align: center; font-size: 0.9em; color: #555;">
      Developed by <strong>Vikrant Vikram</strong> | For Research Purpose
    </footer>
  </div>

  <script>
    // Device Detection
    function detectBrowser() {
      const userAgent = navigator.userAgent;
      const browsers = [
        { name: 'Microsoft Edge', test: /Edg/, versionRegex: /Edg\/([0-9.]+)/ },
        { name: 'Mozilla Firefox', test: /Firefox/, versionRegex: /Firefox\/([0-9.]+)/ },
        { name: 'Google Chrome', test: /Chrome(?!.*Edg)/, versionRegex: /Chrome\/([0-9.]+)/ },
        { name: 'Safari', test: /Safari(?!.*Chrome)/, versionRegex: /Version\/([0-9.]+)/ }
      ];
      
      const getVersion = (regex) => {
        const match = userAgent.match(regex);
        return match ? match[1] : 'Unknown';
      };
      
      const detectOS = () => {
        if (/Win/.test(userAgent)) return { name: 'Windows', version: (userAgent.match(/Windows NT ([0-9.]+)/) || [])[1] || 'Unknown' };
        if (/Mac/.test(userAgent)) return { name: 'MacOS', version: (userAgent.match(/Mac OS X ([0-9._]+)/) || [])[1]?.replace(/_/g, '.') || 'Unknown' };
        if (/Linux/.test(userAgent)) return { name: 'Linux', version: 'Unknown' };
        return { name: 'Unknown', version: 'Unknown' };
      };
      
      const detectDeviceType = () => {
        if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(userAgent)) return 'mobile';
        if (/Tablet|iPad/i.test(userAgent)) return 'tablet';
        return 'desktop';
      };
      
      for (const browser of browsers) {
        if (browser.test.test(userAgent)) {
          return {
            name: browser.name,
            version: getVersion(browser.versionRegex),
            os: detectOS(),
            deviceType: detectDeviceType()
          };
        }
      }
      
      return {
        name: 'Unknown',
        version: 'Unknown',
        os: detectOS(),
        deviceType: detectDeviceType()
      };
    }

    function generateDeviceFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('fingerprint', 2, 2);
      const canvasData = canvas.toDataURL();
      
      const fingerprint = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: canvasData.slice(0, 50),
        platform: navigator.platform
      };
      
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }

    const browserInfo = detectBrowser();
    if (browserInfo.deviceType !== 'desktop') {
      document.body.innerHTML = '<div style="text-align:center;margin-top:100px;"><h1>Access Restricted</h1><p>This application only works on PC/Laptop. Mobile and tablet devices are not supported.</p></div>';
      throw new Error('Device not supported');
    }

    const API_BASE = '/api';

    let currentDeviceId = null;
    let currentParticipantId = null;
    let currentSessionNumber = 1;
    let typingStartTime = null;
    let totalCharactersTyped = 0;

    // Recorder variables
    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingEnabled = false;
    let recordingStartPerf = 0;
    const keyEvents = [];
    let sessionMetadata = {};
    const MIN_SLICE_BYTES = 1200;
    const PRE_MS = 60;
    const POST_MS = 200;

    // DOM elements
    let statusEl, keyListEl, inputArea, startBtn, stopBtn, consentChk;
    let pidEl, sessionEl, genderEl, handEl;
    let deviceIdDisplay, osDisplay, browserDisplay, deviceTypeDisplay, sessionInfo;

    document.addEventListener('DOMContentLoaded', async () => {
      statusEl = document.getElementById('status');
      keyListEl = document.getElementById('keyList');
      inputArea = document.getElementById('inputArea');
      startBtn = document.getElementById('startBtn');
      stopBtn = document.getElementById('stopBtn');
      consentChk = document.getElementById('consentChk');
      pidEl = document.getElementById('pid');
      sessionEl = document.getElementById('session');
      genderEl = document.getElementById('gender');
      handEl = document.getElementById('hand');
      deviceIdDisplay = document.getElementById('deviceIdDisplay');
      osDisplay = document.getElementById('osDisplay');
      browserDisplay = document.getElementById('browserDisplay');
      deviceTypeDisplay = document.getElementById('deviceTypeDisplay');
      sessionInfo = document.getElementById('sessionInfo');

      if (!statusEl || !keyListEl || !inputArea || !startBtn || !stopBtn) {
        console.error('Missing required DOM elements');
        alert('Page error: Missing required elements. Please refresh.');
        return;
      }

      // Fill device info
      osDisplay.value = `${browserInfo.os.name} ${browserInfo.os.version}`;
      browserDisplay.value = `${browserInfo.name} ${browserInfo.version}`;
      deviceTypeDisplay.value = browserInfo.deviceType.charAt(0).toUpperCase() + browserInfo.deviceType.slice(1);

      await registerDevice();
      await getNextParticipantId();

      startBtn.addEventListener('click', handleStart);
      stopBtn.addEventListener('click', handleStop);
      inputArea.addEventListener('keydown', handleKeydown);
    });

    async function registerDevice() {
      const fingerprint = generateDeviceFingerprint();
      const osInfo = browserInfo.os;
      
      try {
        statusEl.innerText = 'Registering device...';
        const response = await fetch(`${API_BASE}/register-device`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            deviceFingerprint: fingerprint, 
            browserInfo,
            osInfo 
          })
        });
        const data = await response.json();
        currentDeviceId = data.deviceId;
        deviceIdDisplay.value = currentDeviceId;
        statusEl.innerText = `Device registered: ${currentDeviceId}`;
      } catch (err) {
        console.error('Device registration failed:', err);
        statusEl.innerText = 'Device registration failed. Using offline mode.';
        currentDeviceId = 'D000_OFFLINE';
        deviceIdDisplay.value = currentDeviceId;
      }
    }

    async function getNextParticipantId() {
      try {
        statusEl.innerText = 'Getting participant ID...';
        const response = await fetch(`${API_BASE}/get-next-id`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId: currentDeviceId })
        });
        const data = await response.json();
        currentParticipantId = data.participantId;
        currentSessionNumber = data.sessionNumber || 1;
        
        pidEl.value = currentParticipantId;
        sessionEl.value = currentSessionNumber;
        sessionInfo.innerText = `Session ${currentSessionNumber} for this participant`;
        statusEl.innerText = `Ready! Participant: ${currentParticipantId}, Session: ${currentSessionNumber}`;
      } catch (err) {
        console.error('ID generation failed:', err);
        currentParticipantId = 'U000_OFFLINE';
        pidEl.value = currentParticipantId;
        statusEl.innerText = 'Working in offline mode';
      }
    }

    function safePrefix(s) {
      return String(s || '').replace(/[^a-zA-Z0-9_-]/g, '') || 'NA';
    }

    function metaPrefix() {
      const pid = safePrefix(currentParticipantId);
      const sess = safePrefix(currentSessionNumber);
      const gen = safePrefix(genderEl.value);
      const hand = safePrefix(handEl.value);
      return `${pid}_S${sess}_${gen}_${hand}`;
    }

    function calculateTypingSpeed() {
      if (!typingStartTime || totalCharactersTyped === 0) return { wpm: 0, category: 'Beginner' };
      
      const durationMinutes = (Date.now() - typingStartTime) / 60000;
      const words = totalCharactersTyped / 5; // Standard: 5 characters = 1 word
      const wpm = Math.round(words / durationMinutes);
      
      let category = 'Beginner';
      if (wpm >= 60) category = 'Expert';
      else if (wpm >= 40) category = 'Intermediate';
      
      return { wpm, category };
    }

    async function initMic() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        statusEl.innerText = 'Microphone access granted.';
      } catch (err) {
        statusEl.innerText = 'Microphone access denied: ' + (err && err.name ? err.name : err);
        console.error(err);
      }
    }

    function allMetaProvided() {
      return consentChk.checked && genderEl.value && handEl.value;
    }

    async function handleStart() {
      if (!allMetaProvided()) {
        alert('Please tick consent and select Gender and Handedness.');
        return;
      }
      if (!stream) await initMic();
      if (!stream) return;

      typingStartTime = Date.now();
      totalCharactersTyped = 0;

      sessionMetadata = {
        participant: {
          id: currentParticipantId,
          session: currentSessionNumber,
          gender: genderEl.value || '',
          handedness: handEl.value || ''
        },
        device: {
          deviceId: currentDeviceId,
          browser: browserInfo.name,
          browserVersion: browserInfo.version,
          os: browserInfo.os.name,
          osVersion: browserInfo.os.version,
          deviceType: browserInfo.deviceType
        },
        start_time_utc: (new Date()).toISOString(),
        pre_ms: PRE_MS,
        post_ms: POST_MS,
        sample_rate: null,
        num_channels: null,
        keys: [],
        typing_speed: null,
        typing_category: null,
        environment: { note: '', noise_level: '' },
        generated_at: null,
        duration_s: null,
        exported_files: []
      };

      recordedChunks.length = 0;
      keyEvents.length = 0;

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = async () => {
        statusEl.innerText = 'Recording stopped; processing...';
        await processRecordingAndCreateZip();
      };

      recordingStartPerf = performance.now();
      mediaRecorder.start();
      recordingEnabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      inputArea.disabled = false;
      inputArea.value = ''; // Clear textarea
      statusEl.innerText = 'Recording started. Start typing.';
      inputArea.focus();
    }

    function handleStop() {
      if (!mediaRecorder) return;
      recordingEnabled = false;
      try { mediaRecorder.stop(); } catch (e) {}
      startBtn.disabled = false;
      stopBtn.disabled = true;
      inputArea.disabled = true;
      statusEl.innerText = 'Stopping...';
    }

    function handleKeydown(event) {
      if (!recordingEnabled) return;
      if (['Shift','Control','Alt','Meta'].includes(event.key)) return;
      
      totalCharactersTyped++;
      
      const now = performance.now();
      const t_ms = now - recordingStartPerf;
      const keyLabel = event.key === ' ' ? 'space' : event.key;
      keyEvents.push({ key: keyLabel, t_ms });
      const pressed = keyEvents.map(k=>k.key).slice(-50);
      keyListEl.textContent = pressed.join(', ');
      statusEl.innerText = `Captured ${keyEvents.length} keys`;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function encodeWAVFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const buffer = new ArrayBuffer(44 + length * blockAlign);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * blockAlign, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    async function uploadToGoogleDrive(zipBlob, metadata) {
      try {
        statusEl.innerText = 'Uploading to Google Drive...';
        const reader = new FileReader();
        const base64Data = await new Promise((resolve) => {
          reader.onloadend = () => resolve(reader.result.split(',')[1]);
          reader.readAsDataURL(zipBlob);
        });

        const typingSpeed = calculateTypingSpeed();
        
        const response = await fetch(`${API_BASE}/upload-to-drive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            participantId: currentParticipantId,
            session: currentSessionNumber,
            gender: genderEl.value,
            handedness: handEl.value,
            zipData: base64Data,
            zipFileName: `${metaPrefix()}_session_${currentSessionNumber}.zip`,
            metadata
          })
        });
        
        const result = await response.json();
        if (result.success) {
          statusEl.innerText = `Uploaded! Updating CSV...`;
          
          await fetch(`${API_BASE}/update-csv`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              deviceId: currentDeviceId,
              participantId: currentParticipantId,
              session: currentSessionNumber,
              gender: genderEl.value,
              handedness: handEl.value,
              totalKeys: keyEvents.length,
              browserInfo,
              osInfo: browserInfo.os,
              typingSpeed: typingSpeed.wpm,
              typingCategory: typingSpeed.category
            })
          });
          
          statusEl.innerText = `âœ“ Complete! WPM: ${typingSpeed.wpm} (${typingSpeed.category})`;
          
          // Clear textarea after successful upload
          inputArea.value = '';
        }
      } catch (err) {
        console.error('Upload failed:', err);
        statusEl.innerText = 'Upload failed. File saved locally only.';
      }
    }

    async function processRecordingAndCreateZip() {
      try {
        if (recordedChunks.length === 0) {
          statusEl.innerText = 'No audio recorded.';
          return;
        }
        
        const wholeBlob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
        const wholeExt = (recordedChunks[0] && recordedChunks[0].type && recordedChunks[0].type.includes('webm')) ? 'webm' : 'ogg';
        const arrayBuffer = await wholeBlob.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
        
        const typingSpeed = calculateTypingSpeed();
        
        sessionMetadata.sample_rate = decoded.sampleRate;
        sessionMetadata.duration_s = decoded.duration;
        sessionMetadata.num_channels = decoded.numberOfChannels;
        sessionMetadata.keys = keyEvents.map(k => ({ key: k.key, t_ms: k.t_ms }));
        sessionMetadata.typing_speed = typingSpeed.wpm;
        sessionMetadata.typing_category = typingSpeed.category;
        sessionMetadata.generated_at = (new Date()).toISOString();
        sessionMetadata.total_events = keyEvents.length;

        const zip = new JSZip();
        zip.file(`${metaPrefix()}_continuous.${wholeExt}`, wholeBlob);

        const filesMeta = [];
        for (let i = 0; i < keyEvents.length; i++) {
          const ev = keyEvents[i];
          const start_s = Math.max(0, (ev.t_ms - PRE_MS) / 1000);
          const end_s = Math.min(decoded.duration, (ev.t_ms + POST_MS) / 1000);
          const startSample = Math.floor(start_s * decoded.sampleRate);
          const endSample = Math.ceil(end_s * decoded.sampleRate);
          const sliceLength = endSample - startSample;
          if (sliceLength <= 0) continue;

          const numChannels = decoded.numberOfChannels;
          const sliceBuffer = audioCtx.createBuffer(numChannels, sliceLength, decoded.sampleRate);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = decoded.getChannelData(ch).subarray(startSample, endSample);
            sliceBuffer.copyToChannel(channelData, ch, 0);
          }

          const wavBlob = encodeWAVFromAudioBuffer(sliceBuffer);
          if (wavBlob.size < MIN_SLICE_BYTES) continue;

          const keySafe = String(ev.key).replace(/[^a-zA-Z0-9_-]/g, '') || 'key';
          const filename = `${metaPrefix()}_key${String(i+1).padStart(4,'0')}_${keySafe}_${Math.round(ev.t_ms)}ms.wav`;

          zip.file(filename, wavBlob);
          filesMeta.push({ filename, key: ev.key, t_ms: ev.t_ms, size_bytes: wavBlob.size });
          
          if (i % 10 === 0) {
            statusEl.innerText = `Processing: ${i}/${keyEvents.length}`;
            await new Promise(r => setTimeout(r, 1));
          }
        }

        sessionMetadata.exported_files = filesMeta;
        zip.file(`${metaPrefix()}_metadata.json`, JSON.stringify(sessionMetadata, null, 2));

        statusEl.innerText = 'Creating ZIP...';
        const zipBlob = await zip.generateAsync({ 
          type: 'blob', 
          compression: 'DEFLATE', 
          compressionOptions: { level: 6 } 
        }, (meta) => {
          statusEl.innerText = `Zipping: ${Math.round(meta.percent)}%`;
        });

        await uploadToGoogleDrive(zipBlob, sessionMetadata);

        const zipFilename = `${metaPrefix()}_session_${currentSessionNumber}.zip`;
        triggerDownload(zipBlob, zipFilename);
      } catch (err) {
        console.error('Processing error:', err);
        statusEl.innerText = 'Error: ' + err.message;
      }
    }

    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }
  </script>
</body>
</html>
