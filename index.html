<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Keystroke Sound Recorder (WAV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f5f7fa;
      display: flex;
      justify-content: center;
      align-items: start;
      min-height: 100vh;
      margin: 0;
      padding: 24px;
      color: #222;
    }
    .container {
      background: #ffffff;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      width: 100%;
      max-width: 900px;
    }
    h1 {
      font-size: 1.8em;
      color: #333;
      margin: 0 0 6px 0;
    }
    h2 {
      margin: 24px 0 8px;
      font-size: 1.2em;
      color: #333;
    }
    p {
      font-size: 0.98em;
      color: #555;
      margin: 0 0 14px 0;
      line-height: 1.5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    label {
      font-size: 0.92em;
      color: #333;
      display: block;
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      font-size: 1em;
      border: 2px solid #ddd;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      transition: border-color 0.2s;
      background: #fff;
    }
    input:disabled, select:disabled {
      background: #f0f0f0;
      color: #666;
      cursor: not-allowed;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4a90e2;
    }
    textarea {
      width: 100%;
      padding: 14px;
      font-size: 1.05em;
      border: 2px solid #ddd;
      border-radius: 8px;
      resize: vertical;
      min-height: 160px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      transition: border-color 0.2s;
      background: #fff;
    }
    .btn {
      background-color: #4a90e2;
      color: #fff;
      border: none;
      padding: 10px 18px;
      font-size: 0.98em;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .btn:hover { background-color: #357ab8; }
    .btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .btn.secondary {
      background-color: #6b7280;
    }
    .btn.secondary:hover { background-color: #4b5563; }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .muted {
      color: #666;
      font-size: 0.9em;
    }
    .status {
      margin-top: 12px;
      font-size: 0.95em;
      color: #444;
      min-height: 24px;
    }
    .pressed-keys {
      margin-top: 10px;
      font-size: 0.95em;
      color: #222;
      word-wrap: break-word;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
      color: #1f2937;
    }
    .consent {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 10px 0 4px;
    }
    .note {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      color: #7c2d12;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 0.95em;
    }
    .info-badge {
      display: inline-block;
      background: #e0f2fe;
      color: #0369a1;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.9em;
      margin-top: 8px;
    }
    .sep { height: 1px; background: #e5e7eb; margin: 18px 0; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Keystroke Sound Recorder</h1>
    <p class="muted">
      This page records short audio snippets around each key press while you type a standardized paragraph.
    </p>

    <div class="note">
      Grant microphone access when prompted. Keep your environment quiet to reduce background noise.
    </div>

    <h2>Device Information</h2>
    <div class="grid">
      <div>
        <label for="deviceIdDisplay">Device ID</label>
        <input id="deviceIdDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="osDisplay">Operating System</label>
        <input id="osDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="browserDisplay">Browser</label>
        <input id="browserDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="deviceTypeDisplay">Device Type</label>
        <input id="deviceTypeDisplay" type="text" readonly disabled />
      </div>
    </div>

    <h2>Participant Details</h2>
    <div class="grid">
      <div>
        <label for="pid">Participant ID</label>
        <input id="pid" type="text" readonly disabled />
      </div>
      <div>
        <label for="session">Session Number</label>
        <input id="session" type="number" min="1" value="1" readonly disabled />
        <span class="info-badge" id="sessionInfo">Auto-detected</span>
      </div>
      <div>
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="">Select</option>
          <option>Female</option>
          <option>Male</option>
          <option>Other</option>
          <option>Prefer not to say</option>
        </select>
      </div>
      <div>
        <label for="hand">Handedness</label>
        <select id="hand">
          <option value="">Select</option>
          <option>Left</option>
          <option>Right</option>
          <option>Ambidextrous</option>
        </select>
      </div>
    </div>

    <div class="consent">
      <input type="checkbox" id="consentChk" />
      <label for="consentChk">I consent to participate in this research recording.</label>
    </div>

    <div class="sep"></div>

    <h2>Paragraph to Type</h2>
    <p class="muted">Type the paragraph below exactly as shown.</p>

    <pre>The quick brown fox jumps over the lazy dog while amazing zebras quietly vex jumpy kids, proving every letter is present. Pack my box with five dozen liquor jugs to verify the alphabet twice.
Digits appear forward and backward: 1234567890 then 0987654321, followed by sequences like 2468, 13579, and 314159.
Now we add punctuation: . , ; : ? ! ' " - _ ( ) [ ] { } / \
Symbols and operators: @ # $ % ^ & * + = &lt; &gt; | ~
To include uppercase properly, acronyms like NASA, USA, UN, AI, ML, and HTML are written in full caps.
Typing speed and accuracy will be measured across every key, ensuring consistency of captured events.
Finally, we conclude with a mix: The year is 2025; version v1.0-beta includes features [alpha], {bravo}, and (charlie), all typed carefully for complete coverage of the QWERTY keyboard.</pre>

    <h2>Typing Box</h2>
    <textarea id="inputArea" rows="8" placeholder="Start typing after clicking 'Start Recording'" disabled></textarea>

    <div class="button-row">
      <button class="btn" id="startBtn">Start Recording</button>
      <button class="btn" id="stopBtn" disabled>Stop Recording</button>
    </div>

    <div class="status" id="status">Loading...</div>
    <div class="pressed-keys">
      <strong>Keys Pressed:</strong> <span id="keyList"></span>
    </div>

    <footer style="margin-top: 40px; padding-top: 12px; border-top: 1px solid #e5e7eb; text-align: center; font-size: 0.9em; color: #555;">
      Developed by <strong>Vikrant Vikram</strong> | For Research Purpose
    </footer>
  </div>

  <script>
    // Device Detection (same as before)
    function detectBrowser() {
      const userAgent = navigator.userAgent;
      const browsers = [
        { name: 'Microsoft Edge', test: /Edg/, versionRegex: /Edg\/([0-9.]+)/ },
        { name: 'Mozilla Firefox', test: /Firefox/, versionRegex: /Firefox\/([0-9.]+)/ },
        { name: 'Google Chrome', test: /Chrome(?!.*Edg)/, versionRegex: /Chrome\/([0-9.]+)/ },
        { name: 'Safari', test: /Safari(?!.*Chrome)/, versionRegex: /Version\/([0-9.]+)/ }
      ];
      
      const getVersion = (regex) => {
        const match = userAgent.match(regex);
        return match ? match[1] : 'Unknown';
      };
      
      const detectOS = () => {
        if (/Win/.test(userAgent)) return { name: 'Windows', version: (userAgent.match(/Windows NT ([0-9.]+)/) || [])[1] || 'Unknown' };
        if (/Mac/.test(userAgent)) return { name: 'MacOS', version: (userAgent.match(/Mac OS X ([0-9._]+)/) || [])[1]?.replace(/_/g, '.') || 'Unknown' };
        if (/Linux/.test(userAgent)) return { name: 'Linux', version: 'Unknown' };
        return { name: 'Unknown', version: 'Unknown' };
      };
      
      const detectDeviceType = () => {
        if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(userAgent)) return 'mobile';
        if (/Tablet|iPad/i.test(userAgent)) return 'tablet';
        return 'desktop';
      };
      
      for (const browser of browsers) {
        if (browser.test.test(userAgent)) {
          return {
            name: browser.name,
            version: getVersion(browser.versionRegex),
            os: detectOS(),
            deviceType: detectDeviceType()
          };
        }
      }
      
      return {
        name: 'Unknown',
        version: 'Unknown',
        os: detectOS(),
        deviceType: detectDeviceType()
      };
    }

    function generateDeviceFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('fingerprint', 2, 2);
      const canvasData = canvas.toDataURL();
      
      const fingerprint = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: canvasData.slice(0, 50),
        platform: navigator.platform
      };
      
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }

    // const browserInfo = detectBrowser();
    // if (browserInfo.deviceType !== 'desktop') {
    //   document.body.innerHTML = '<div style="text-align:center;margin-top:100px;"><h1>Access Restricted</h1><p>This application only works on PC/Laptop.</p></div>';
    //   throw new Error('Device not supported');
    // }
      const browserInfo = detectBrowser();
    const API_BASE = '/api';
    let currentDeviceId = null;
    let currentParticipantId = null;
    let currentSessionNumber = 1;
    let typingStartTime = null;
    let totalCharactersTyped = 0;

    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingEnabled = false;
    let recordingStartPerf = 0;
    const keyEvents = [];
    let sessionMetadata = {};
    const MIN_SLICE_BYTES = 1200;
    const PRE_MS = 60;
    const POST_MS = 200;

    let statusEl, keyListEl, inputArea, startBtn, stopBtn, consentChk;
    let pidEl, sessionEl, genderEl, handEl;
    let deviceIdDisplay, osDisplay, browserDisplay, deviceTypeDisplay, sessionInfo;

    document.addEventListener('DOMContentLoaded', async () => {
      statusEl = document.getElementById('status');
      keyListEl = document.getElementById('keyList');
      inputArea = document.getElementById('inputArea');
      startBtn = document.getElementById('startBtn');
      stopBtn = document.getElementById('stopBtn');
      consentChk = document.getElementById('consentChk');
      pidEl = document.getElementById('pid');
      sessionEl = document.getElementById('session');
      genderEl = document.getElementById('gender');
      handEl = document.getElementById('hand');
      deviceIdDisplay = document.getElementById('deviceIdDisplay');
      osDisplay = document.getElementById('osDisplay');
      browserDisplay = document.getElementById('browserDisplay');
      deviceTypeDisplay = document.getElementById('deviceTypeDisplay');
      sessionInfo = document.getElementById('sessionInfo');

      osDisplay.value = `${browserInfo.os.name} ${browserInfo.os.version}`;
      browserDisplay.value = `${browserInfo.name} ${browserInfo.version}`;
      deviceTypeDisplay.value = browserInfo.deviceType.charAt(0).toUpperCase() + browserInfo.deviceType.slice(1);

      console.log('Initializing application...');
      await registerDevice();
      await getNextParticipantId();

      startBtn.addEventListener('click', handleStart);
      stopBtn.addEventListener('click', handleStop);
      inputArea.addEventListener('keydown', handleKeydown);
    });

    async function registerDevice() {
      const fingerprint = generateDeviceFingerprint();
      
      try {
        statusEl.innerText = 'Registering device...';
        console.log('Calling register-device API with fingerprint:', fingerprint);
        
        const response = await fetch(`${API_BASE}/register-device`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            deviceFingerprint: fingerprint, 
            browserInfo,
            osInfo: browserInfo.os 
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Register device failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Register device response:', data);
        
        if (!data.deviceId) {
          throw new Error('No deviceId in response');
        }
        
        currentDeviceId = data.deviceId;
        deviceIdDisplay.value = currentDeviceId;
        statusEl.innerText = `Device registered: ${currentDeviceId}`;
        console.log('Device registered successfully:', currentDeviceId);
      } catch (err) {
        console.error('Device registration error:', err);
        statusEl.innerText = `Registration failed: ${err.message}. Check console (F12).`;
        alert('Device registration failed. Please check:\n1. Environment variables in Vercel\n2. Service account permissions\n3. Console (F12) for errors');
      }
    }

    async function getNextParticipantId() {
      if (!currentDeviceId) {
        console.error('Cannot get participant ID: no device ID');
        statusEl.innerText = 'Error: Device not registered';
        return;
      }
      
      try {
        statusEl.innerText = 'Getting participant ID...';
        console.log('Calling get-next-id API for device:', currentDeviceId);
        
        const response = await fetch(`${API_BASE}/get-next-id`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId: currentDeviceId })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Get ID failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Get ID response:', data);
        
        if (!data.participantId) {
          throw new Error('No participantId in response');
        }
        
        currentParticipantId = data.participantId;
        currentSessionNumber = data.sessionNumber || 1;
        
        pidEl.value = currentParticipantId;
        sessionEl.value = currentSessionNumber;
        sessionInfo.innerText = `Session ${currentSessionNumber}`;
        statusEl.innerText = `Ready! ${currentParticipantId}, Session ${currentSessionNumber}`;
        console.log('Setup complete:', { currentParticipantId, currentSessionNumber });
      } catch (err) {
        console.error('Get participant ID error:', err);
        statusEl.innerText = `ID generation failed: ${err.message}. Check console.`;
        alert('Participant ID generation failed. Check console (F12) for details.');
      }
    }

    function calculateTypingSpeed() {
      if (!typingStartTime || totalCharactersTyped === 0) return { wpm: 0, category: 'Beginner' };
      
      const durationMinutes = (Date.now() - typingStartTime) / 60000;
      const words = totalCharactersTyped / 5;
      const wpm = Math.round(words / durationMinutes);
      
      let category = 'Beginner';
      if (wpm >= 60) category = 'Expert';
      else if (wpm >= 40) category = 'Intermediate';
      
      return { wpm, category };
    }

    async function initMic() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        statusEl.innerText = 'Microphone granted.';
      } catch (err) {
        statusEl.innerText = 'Microphone denied: ' + err.name;
        console.error(err);
      }
    }

    function allMetaProvided() {
      return consentChk.checked && genderEl.value && handEl.value && currentParticipantId;
    }

    async function handleStart() {
      if (!currentParticipantId) {
        alert('Please wait for participant ID to load');
        return;
      }
      
      if (!allMetaProvided()) {
        alert('Please tick consent and select Gender and Handedness.');
        return;
      }
      
      if (!stream) await initMic();
      if (!stream) return;

      typingStartTime = Date.now();
      totalCharactersTyped = 0;

      sessionMetadata = {
        participant: {
          id: currentParticipantId,
          session: currentSessionNumber,
          gender: genderEl.value,
          handedness: handEl.value
        },
        device: {
          deviceId: currentDeviceId,
          browser: browserInfo.name,
          browserVersion: browserInfo.version,
          os: browserInfo.os.name,
          osVersion: browserInfo.os.version,
          deviceType: browserInfo.deviceType
        },
        start_time_utc: new Date().toISOString(),
        pre_ms: PRE_MS,
        post_ms: POST_MS
      };

      recordedChunks.length = 0;
      keyEvents.length = 0;

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = async () => {
        statusEl.innerText = 'Processing recording...';
        await processRecordingAndCreateZip();
      };

      recordingStartPerf = performance.now();
      mediaRecorder.start();
      recordingEnabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      inputArea.disabled = false;
      inputArea.value = '';
      statusEl.innerText = 'ðŸ”´ Recording... Start typing!';
      inputArea.focus();
    }

    function handleStop() {
      if (!mediaRecorder) return;
      recordingEnabled = false;
      try { mediaRecorder.stop(); } catch (e) {}
      startBtn.disabled = false;
      stopBtn.disabled = true;
      inputArea.disabled = true;
      statusEl.innerText = 'Stopping and processing...';
    }

    function handleKeydown(event) {
      if (!recordingEnabled) return;
      if (['Shift','Control','Alt','Meta'].includes(event.key)) return;
      
      totalCharactersTyped++;
      
      const now = performance.now();
      const t_ms = now - recordingStartPerf;
      const keyLabel = event.key === ' ' ? 'space' : event.key;
      keyEvents.push({ key: keyLabel, t_ms });
      keyListEl.textContent = keyEvents.map(k=>k.key).slice(-30).join(', ');
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function encodeWAVFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const buffer = new ArrayBuffer(44 + length * blockAlign);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * blockAlign, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    async function uploadToGoogleDrive(zipBlob, metadata) {
      try {
        statusEl.innerText = 'Uploading to Google Drive...';
        console.log('Starting upload...');
        
        const reader = new FileReader();
        const base64Data = await new Promise((resolve, reject) => {
          reader.onloadend = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(zipBlob);
        });

        console.log('ZIP converted to base64, length:', base64Data.length);

        const typingSpeed = calculateTypingSpeed();
        console.log('Typing speed:', typingSpeed);
        
        const zipFileName = `${currentParticipantId}_S${currentSessionNumber}_${genderEl.value}_${handEl.value}.zip`;
        console.log('Uploading file:', zipFileName);
        
        const uploadResponse = await fetch(`${API_BASE}/upload-to-drive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            participantId: currentParticipantId,
            session: currentSessionNumber,
            gender: genderEl.value,
            handedness: handEl.value,
            zipData: base64Data,
            zipFileName
          })
        });
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          console.error('Upload failed:', errorText);
          throw new Error(`Upload failed: ${errorText}`);
        }
        
        const uploadResult = await uploadResponse.json();
        console.log('Upload successful:', uploadResult);
        
        if (!uploadResult.success) {
          throw new Error('Upload reported failure');
        }
        
        statusEl.innerText = 'Updating CSV...';
        
        const csvResponse = await fetch(`${API_BASE}/update-csv`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            participantId: currentParticipantId,
            session: currentSessionNumber,
            gender: genderEl.value,
            handedness: handEl.value,
            totalKeys: keyEvents.length,
            browserInfo,
            osInfo: browserInfo.os,
            typingSpeed: typingSpeed.wpm,
            typingCategory: typingSpeed.category
          })
        });
        
        if (!csvResponse.ok) {
          console.error('CSV update failed');
        } else {
          console.log('CSV updated successfully');
        }
        
        statusEl.innerText = `âœ… COMPLETED! WPM: ${typingSpeed.wpm} (${typingSpeed.category}) | File uploaded successfully`;
        inputArea.value = '';
        
        setTimeout(() => {
          alert(`Recording complete!\n\nParticipant: ${currentParticipantId}\nSession: ${currentSessionNumber}\nTyping Speed: ${typingSpeed.wpm} WPM (${typingSpeed.category})\n\nFile uploaded to Google Drive!`);
        }, 500);
        
      } catch (err) {
        console.error('Upload process error:', err);
        statusEl.innerText = `âŒ Upload failed: ${err.message}. File saved locally.`;
      }
    }

    async function processRecordingAndCreateZip() {
      try {
        if (recordedChunks.length === 0) {
          statusEl.innerText = 'No audio recorded.';
          return;
        }
        
        const wholeBlob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
        const arrayBuffer = await wholeBlob.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        
        const typingSpeed = calculateTypingSpeed();
        
        sessionMetadata.sample_rate = decoded.sampleRate;
        sessionMetadata.duration_s = decoded.duration;
        sessionMetadata.num_channels = decoded.numberOfChannels;
        sessionMetadata.keys = keyEvents.map(k => ({ key: k.key, t_ms: k.t_ms }));
        sessionMetadata.typing_speed = typingSpeed.wpm;
        sessionMetadata.typing_category = typingSpeed.category;
        sessionMetadata.generated_at = new Date().toISOString();
        sessionMetadata.total_events = keyEvents.length;

        const zip = new JSZip();
        const wholeExt = wholeBlob.type.includes('webm') ? 'webm' : 'ogg';
        zip.file(`continuous_audio.${wholeExt}`, wholeBlob);

        statusEl.innerText = `Processing ${keyEvents.length} keys...`;

        const filesMeta = [];
        for (let i = 0; i < keyEvents.length; i++) {
          const ev = keyEvents[i];
          const start_s = Math.max(0, (ev.t_ms - PRE_MS) / 1000);
          const end_s = Math.min(decoded.duration, (ev.t_ms + POST_MS) / 1000);
          const startSample = Math.floor(start_s * decoded.sampleRate);
          const endSample = Math.ceil(end_s * decoded.sampleRate);
          const sliceLength = endSample - startSample;
          
          if (sliceLength <= 0) continue;

          const numChannels = decoded.numberOfChannels;
          const sliceBuffer = audioCtx.createBuffer(numChannels, sliceLength, decoded.sampleRate);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = decoded.getChannelData(ch).subarray(startSample, endSample);
            sliceBuffer.copyToChannel(channelData, ch, 0);
          }

          const wavBlob = encodeWAVFromAudioBuffer(sliceBuffer);
          if (wavBlob.size < MIN_SLICE_BYTES) continue;

          const keySafe = String(ev.key).replace(/[^a-zA-Z0-9_-]/g, '') || 'key';
          const filename = `key_${String(i+1).padStart(4,'0')}_${keySafe}_${Math.round(ev.t_ms)}ms.wav`;

          zip.file(filename, wavBlob);
          filesMeta.push({ filename, key: ev.key, t_ms: ev.t_ms, size_bytes: wavBlob.size });
          
          if (i % 20 === 0 || i === keyEvents.length - 1) {
            statusEl.innerText = `Processing: ${i+1}/${keyEvents.length}`;
            await new Promise(r => setTimeout(r, 1));
          }
        }

        sessionMetadata.exported_files = filesMeta;
        zip.file('metadata.json', JSON.stringify(sessionMetadata, null, 2));

        statusEl.innerText = 'Creating ZIP file...';
        const zipBlob = await zip.generateAsync({ 
          type: 'blob', 
          compression: 'DEFLATE', 
          compressionOptions: { level: 6 } 
        }, (meta) => {
          statusEl.innerText = `Creating ZIP: ${Math.round(meta.percent)}%`;
        });

        console.log('ZIP created, size:', zipBlob.size);

        await uploadToGoogleDrive(zipBlob, sessionMetadata);

        const zipFilename = `${currentParticipantId}_S${currentSessionNumber}_${genderEl.value}_${handEl.value}.zip`;
        triggerDownload(zipBlob, zipFilename);
      } catch (err) {
        console.error('Processing error:', err);
        statusEl.innerText = `Error: ${err.message}`;
        alert('Processing error: ' + err.message);
      }
    }

    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }
  </script>
</body>
</html>
