<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Keystroke Sound Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f7fa;
      display: flex;
      justify-content: center;
      align-items: start;
      min-height: 100vh;
      margin: 0;
      padding: 24px;
      color: #222;
      transition: background 0.3s, color 0.3s;
    }
    body.dark-mode { background: #121212; color: #eee; }
    .container {
      background: #fff;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      width: 100%;
      max-width: 1000px;
    }
    body.dark-mode .container {
      background: #1e1e1e;
      color: #eee;
      box-shadow: 0 4px 20px rgba(0,0,0,.7);
    }

    /* Dark Mode Slider Switch */
    #darkModeSwitchContainer {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 16px;
    }
    .switch { display: flex; align-items: center; gap: 10px; cursor: pointer; font-weight: 600; user-select: none; }
    .switch input[type="checkbox"] { opacity: 0; width: 0; height: 0; position: absolute; }
    .slider { position: relative; display: inline-block; width: 46px; height: 26px; background: #ccc; border-radius: 99px; transition: background 0.3s; vertical-align: middle; }
    .slider:before { content: ""; position: absolute; height: 20px; width: 20px; left: 3px; top: 3px; background: #fff; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.12); transition: transform 0.3s, background 0.3s; }
    .switch input:checked + .slider { background: #4a90e2; }
    .switch input:checked + .slider:before { transform: translateX(20px); background: #fffde4; }
    .switch-label { display: inline-block; margin-left: 12px; font-size: 1em; color: #333; transition: color 0.3s; }
    body.dark-mode .switch-label { color: #f9fafb; }
    body.dark-mode .slider { background: #374151; }
    body.dark-mode .switch input:checked + .slider { background: #ffd600; }

    h1 { font-size: 2em; margin: 0 0 10px 0; font-weight: 600; color: #333; }
    body.dark-mode h1 { color: #eee; }
    h2 { margin: 32px 0 16px; font-size: 1.3em; color: #333; font-weight: 600;}
    body.dark-mode h2 { color: #eee;}
    p { font-size: 0.98em; color: #555; margin: 0 0 14px 0; line-height: 1.6; }
    body.dark-mode p { color: #ccc; }

    .device-grid, .participant-grid {
      display: grid; gap: 16px; margin-top: 10px; margin-bottom: 10px;
    }
    .device-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .participant-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
    label { font-size: 0.92em; color: #333; display: block; margin-bottom: 6px; font-weight: 500;}
    body.dark-mode label { color: #ddd; }
    input, select { width: 100%; padding: 10px 12px; font-size: 1em; border: 2px solid #ddd; border-radius: 8px; background: #fff;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); transition: border-color 0.2s; }
    input:disabled, select:disabled { background: #f0f0f0; color: #666; cursor: not-allowed;}
    input:focus, select:focus, textarea:focus { outline: none; border-color: #4a90e2; }
    body.dark-mode input, body.dark-mode select, body.dark-mode textarea { background: #2c2c2c; color: #eee; border-color: #555; }
    body.dark-mode input:disabled, body.dark-mode select:disabled { background: #444; color: #aaa; }
    textarea {
      width: 100%;
      padding: 16px;
      font-size: 1rem;
      line-height: 1.6;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      resize: vertical;
      min-height: 180px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
    }

    textarea:disabled {
      background: var(--input-disabled);
      color: var(--text-muted);
      cursor: not-allowed;
      opacity: 0.7;
    }

    textarea::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }


    body.dark-mode textarea { background: #2c2c2c; color: #eee;}
    body.dark-mode textarea:disabled { background: #444; color: #aaa;}

    pre {
    white-space: pre-wrap;
    word-break: break-word;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-light);
    border-radius: 8px;
    padding: 16px;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.95rem;
    line-height: 1.8;
    color: var(--text-primary);
    overflow-x: auto;
    margin: 12px 0;
  }


    .btn {
      background-color: #4a90e2;
      color: #fff;
      border: none;
      padding: 12px 20px;
      font-size: 1em;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      font-weight: 600;
    }
    .btn:hover { background-color: #357ab8; transform: translateY(-1px);}
    .btn:active { transform: translateY(0);}
    .btn:disabled { background-color: #ccc; cursor: not-allowed; transform: none;}
    .btn.secondary { background-color: #6b7280;}
    .btn.secondary:hover { background-color: #4b5563;}
    .button-row { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 16px; align-items: center; }
    body.dark-mode .btn { background-color: #357ab8;}
    body.dark-mode .btn:hover { background-color: #2563eb; }
    body.dark-mode .btn.secondary { background: #4b5563;}
    body.dark-mode .btn.secondary:hover { background: #374151; }

    .muted { color: #666; font-size: 0.9em;}
    body.dark-mode .muted { color: #999; }

    .status { margin-top: 16px; font-size: 1em; color: #444; min-height: 24px; font-weight: 500;}
    body.dark-mode .status { color: #ddd;}
    .pressed-keys { margin-top: 12px; font-size: 0.95em; color: #222; word-wrap: break-word;}
    body.dark-mode .pressed-keys { color: #ddd;}
    pre { white-space: pre-wrap; word-break: break-word; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; font-family: ui-monospace, 'Courier New', monospace; font-size: 0.95em; color: #1f2937; line-height: 1.7; margin: 12px 0;}
    body.dark-mode pre { background: #2c2c2c; border-color: #555; color: #e0e0e0; }
    .consent { display: flex; align-items: center; gap: 10px; margin: 16px 0 8px;}
    .consent input[type="checkbox"] { transform: scale(1.2); cursor: pointer;}
    .note { background: #fff7ed; border: 1px solid #fed7aa; color: #7c2d12; padding: 12px 16px; border-radius: 8px; font-size: 0.95em; margin: 16px 0;}
    body.dark-mode .note { background: #3a2e1a; border-color: #6b5832; color: #f5deb3;}
    .info-badge { display: inline-block; background: #e0f2fe; color: #0369a1; padding: 4px 10px; border-radius: 4px; font-size: 0.9em; margin-top: 8px; font-weight: 500;}
    body.dark-mode .info-badge { background: #0c4a6e; color: #7dd3fc; }
    .sep { height: 1px; background: #e5e7eb; margin: 24px 0;}
    body.dark-mode .sep { background: #444;}
    footer { margin-top: 48px; padding-top: 16px; border-top: 1px solid #e5e7eb; text-align: center; font-size: 0.9em; color: #555;}
    body.dark-mode footer { border-top-color: #444; color: #999;}
    @keyframes slideIn { from { opacity: 0; transform: translateY(-20px);} to { opacity: 1; transform: translateY(0);} }
    @media (max-width: 768px) {
      .participant-grid, .device-grid { grid-template-columns: 1fr;}
      .container { padding: 18px;}
      h1 { font-size: 1.45em; }
    }
    /* Tab (slider) styling */
    .tab-container { display: flex; justify-content: flex-start; gap: 8px; margin-bottom: 10px;}
    .tab-btn { padding: 8px 16px; border: none; font-size: 1em; background: #e0e7ef; color: #1a2936; border-radius: 8px 8px 0 0; cursor: pointer; font-weight: 600; transition: background 0.2s;}
    .tab-btn.active, .tab-btn:focus { background: #4a90e2; color: #fff; outline: none;}
    body.dark-mode .tab-btn { background: #374151; color: #cbd5e1; }
    body.dark-mode .tab-btn.active { background: #60a5fa; color: #22223b;}
    .tab-content { background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 0 0 10px 10px; border-top: none; padding: 12px 16px; margin-bottom: 12px;}
    body.dark-mode .tab-content { background: #2c2c2c; border-color: #555; color: #e0e0e0;}
    /* Person dropdown styling */
    select option:disabled { color: #999 !important; font-style: italic; background: #f5f5f5;}
    body.dark-mode select option:disabled { color: #666 !important; background: #2a2a2a;}

    /* FIXED: Force pre tag text to be visible */
    .tab-content pre,
    #tabParagraphContent pre,
    #tabSpecialContent pre {
      white-space: pre-wrap !important;
      word-break: break-word !important;
      background: #f8f9fa !important;
      border: 1px solid #dee2e6 !important;
      border-radius: 8px !important;
      padding: 16px !important;
      margin: 12px 0 !important;
      box-shadow: none !important;
      font-family: 'Courier New', Consolas, monospace !important;
      font-size: 14px !important;
      color: #000000 !important;
      line-height: 1.8 !important;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    body.dark-mode .tab-content pre,
    body.dark-mode #tabParagraphContent pre,
    body.dark-mode #tabSpecialContent pre {
      background: #2d3748 !important;
      border-color: #4a5568 !important;
      color: #ffffff !important;
    }



    /* Ensure tab content doesn't have conflicting styles */
    .tab-content {
      background: #f8fafc;
      border-radius: 0 0 8px 8px;
      padding: 16px 14px;
      margin-bottom: 0;
      margin-top: 0;
      border: 1px solid #e5e7eb;
      border-top: none;
    }

    body.dark-mode .tab-content {
      background: #2c2c2c;
      color: #e0e0e0;
      border-color: #555;
    }

    .consent {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 16px 0 20px 0;
      padding: 0;
    }

    .consent input[type="checkbox"] {
      flex-shrink: 0;
      width: 18px;
      height: 18px;
      margin: 0;
      cursor: pointer;
      accent-color: #4a90e2;
    }

    .consent label {
      margin: 0;
      padding: 0;
      font-size: 1em;
      color: #333;
      font-weight: 500;
      cursor: pointer;
      line-height: 1.4;
    }

    body.dark-mode .consent label {
      color: #eee;
    }

    body.dark-mode .consent input[type="checkbox"] {
      accent-color: #60a5fa;
    }

    /* Tab Styles */
    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--border-light);
    }
    .tab-button {
      background: transparent;
      border: none;
      padding: 12px 20px;
      font-size: 1em;
      font-weight: 600;
      color: var(--text-muted);
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
      position: relative;
      bottom: -2px;
    }
    .tab-button:hover {
      color: var(--accent-primary);
    }
    .tab-button.active {
      color: var(--accent-primary);
      border-bottom-color: var(--accent-primary);
    }
    .instruction-box {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 16px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }
    .instruction-box h3 {
      margin: 0 0 10px 0;
      font-size: 1.1em;
      font-weight: 700;
    }
    .instruction-box ol {
      margin: 8px 0 0 0;
      padding-left: 20px;
      line-height: 1.8;
    }
    .instruction-box li {
      margin-bottom: 6px;
    }
    .instruction-box strong {
      font-weight: 700;
      text-decoration: underline;
    }


  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js">// Force first tab visible immediately
window.addEventListener('load', function() {
  const tabPara = document.getElementById('tabParagraphContent');
  const tabSpecial = document.getElementById('tabSpecialContent');
  const btnPara = document.getElementById('tab-paragraph');
  const btnSpecial = document.getElementById('tab-special');
  
  // Make sure paragraph tab is active
  if (tabPara) {
    tabPara.classList.add('active');
    tabPara.style.display = 'block';
  }
  if (tabSpecial) {
    tabSpecial.classList.remove('active');
    tabSpecial.style.display = 'none';
  }
  if (btnPara) btnPara.classList.add('active');
  if (btnSpecial) btnSpecial.classList.remove('active');
  
  console.log('‚úÖ Tabs initialized');
});
</script>
</head>
<body>
  <div class="container">
    <!-- Dark Mode Slider Switch -->
    <div id="darkModeSwitchContainer">
      <label class="switch">
        <input type="checkbox" id="darkModeToggle" />
        <span class="slider"></span>
        <span class="switch-label" id="darkModeSwitchLabel">üåô Dark Mode</span>
      </label>
    </div>

    <h1>Keystroke Sound Recorder</h1>
    <p class="muted">
      This application records audio snippets around each keystroke while you type a standardized paragraph for research purposes.
    </p>
    <div class="note">
      ‚ö†Ô∏è Grant microphone access when prompted. Keep your environment quiet to reduce background noise.
    </div>

    <h2>Device Information</h2>
    <div class="device-grid">
      <div>
        <label for="deviceIdDisplay">Device ID</label>
        <input id="deviceIdDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="osDisplay">Operating System</label>
        <input id="osDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="browserDisplay">Browser</label>
        <input id="browserDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="deviceTypeDisplay">Device Type</label>
        <input id="deviceTypeDisplay" type="text" readonly disabled />
      </div>
    </div>

    <h2>Participant Details</h2>
    <div class="participant-grid">
      <div>
        <label for="pid">Participant ID</label>
        <input id="pid" type="text" readonly disabled />
      </div>
      <div>
        <label for="session">Session Number</label>
        <input id="session" type="number" min="1" value="1" readonly disabled />
        <span class="info-badge" id="sessionInfo">Session 1</span>
      </div>
      <div>
        <label for="person">Person</label>
        <select id="person">
          <option value="1">Person 1</option>
          <option value="2">Person 2</option>
          <option value="3">Person 3</option>
          <option value="4">Person 4</option>
          <option value="5">Person 5</option>
        </select>
      </div>
      <div>
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="">Select</option>
          <option>Female</option>
          <option>Male</option>
          <option>Other</option>
          <option>Prefer not to say</option>
        </select>
      </div>
      <div>
        <label for="hand">Handedness</label>
        <select id="hand">
          <option value="">Select</option>
          <option>Left</option>
          <option>Right</option>
          <option>Ambidextrous</option>
        </select>
      </div>
    </div>
    <div class="consent">
      <input type="checkbox" id="consentChk" />
      <label for="consentChk">I consent to participate in this research recording.</label>
    </div>

    <!-- Instructions Box -->
    <div class="instruction-box">
      <h3>üìù Typing Instructions</h3>
      <ol>
        <li><strong>Step 1:</strong> Click "Start Recording" button below</li>
        <li><strong>Step 2:</strong> Type the complete <strong>"Paragraph to Type"</strong> exactly as shown</li>
        <li><strong>Step 3:</strong> Switch to <strong>"Special Key Block"</strong> tab and type that text</li>
        <li><strong>Step 4:</strong> Click "Stop Recording" when finished with both the tabs</li>
        <li><strong>Important:</strong> Both forms which appear after submission are mandatory!</li>
      </ol>
    </div>


    <div class="sep"></div>
    <!-- Tab/Slider for paragraph or special keys -->
    <div class="tab-container">
      <button class="tab-btn active" id="tab-paragraph" type="button">Paragraph to Type</button>
      <button class="tab-btn" id="tab-special" type="button">Special Key Block</button>
    </div>

    <div class="tab-content active" id="tabParagraphContent">

  <pre>The quick brown fox jumps over the lazy dog while amazing zebras quietly vex jumpy kids, proving every letter is present. Pack my box with five dozen liquor jugs to verify the alphabet twice.
Digits appear forward and backward: 1234567890 then 0987654321, followed by sequences like 2468, 13579, and 314159.
Now we add punctuation: . , ; : ? ! ' " - _ ( ) [ ] { } / \
Symbols and operators: @ # $ % ^ & * + = &lt; &gt; | ~
To include uppercase properly, acronyms like NASA, USA, UN, AI, ML, and HTML are written in full caps.
Typing speed and accuracy will be measured across every key, ensuring consistency of captured events.
Finally, we conclude with a mix: The year is 2025; version v1.0-beta includes features [alpha], {bravo}, and (charlie), all typed carefully for complete coverage of the QWERTY keyboard.</pre>

    </div>
    <div class="tab-content" id="tabSpecialContent" style="display:none">
      <pre>
1) Tab
2) Backspace
3) Delete
4) Arrow Up
5) Arrow Down
6) Arrow Left
7) Arrow Right
8) Esc
9) F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12
10) Caps Lock (press once to enable, once to disable)
11) Enter (to confirm completion)</pre>
    </div>
    <!-- Now the typing box and start/stop buttons go below as before -->

    <h2>Typing Box</h2>
    <p class="muted">Click inside and start typing after clicking 'Start Recording'.</p>
    <textarea id="inputArea" rows="8" placeholder="Start typing after clicking 'Start Recording'" disabled></textarea>
    <div class="button-row">
      <button class="btn" id="startBtn">Start Recording</button>
      <button class="btn" id="stopBtn" disabled>Stop Recording</button>
      <button class="btn secondary" id="clearBtn">Clear Box</button>
    </div>
    <div class="status" id="status">Loading...</div>
    <div class="pressed-keys">
      <strong>Keys Pressed:</strong> <span id="keyList"></span>
    </div>

    <footer>
       For Research Purposes
    </footer>
  </div>

  <script>
    // ==================== DARK MODE TOGGLE ====================
    const darkModeToggle = document.getElementById('darkModeToggle');
    const switchLabel = document.getElementById('darkModeSwitchLabel');
    
    if (localStorage.getItem('darkModeEnabled') === 'true') {
      document.body.classList.add('dark-mode');
      darkModeToggle.checked = true;
      switchLabel.textContent = '‚òÄÔ∏è Light Mode';
    } else {
      switchLabel.textContent = 'üåô Dark Mode';
    }
    
    darkModeToggle.addEventListener('change', () => {
      if (darkModeToggle.checked) {
        document.body.classList.add('dark-mode');
        localStorage.setItem('darkModeEnabled', 'true');
        switchLabel.textContent = '‚òÄÔ∏è Light Mode';
      } else {
        document.body.classList.remove('dark-mode');
        localStorage.setItem('darkModeEnabled', 'false');
        switchLabel.textContent = 'üåô Dark Mode';
      }
    });

    const tabParagraph = document.getElementById('tab-paragraph');
    const tabSpecial = document.getElementById('tab-special');
    const tabParagraphContent = document.getElementById('tabParagraphContent');
    const tabSpecialContent = document.getElementById('tabSpecialContent');

    tabParagraph.addEventListener('click', () => {
      tabParagraph.classList.add('active');
      tabSpecial.classList.remove('active');
      tabParagraphContent.style.display = '';
      tabSpecialContent.style.display = 'none';
      });
    tabSpecial.addEventListener('click', () => {
      tabSpecial.classList.add('active');
      tabParagraph.classList.remove('active');
      tabSpecialContent.style.display = '';
      tabParagraphContent.style.display = 'none';
      });

     // FIXED: Aggressive text visibility enforcement
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
      const allPre = document.querySelectorAll('.tab-content pre, #tabParagraphContent pre, #tabSpecialContent pre');
      
      allPre.forEach(function(pre, index) {
        // Use cssText for maximum override power
        pre.style.cssText = `
          display: block !important;
          visibility: visible !important;
          opacity: 1 !important;
          color: #000000 !important;
          background: #f8f9fa !important;
          padding: 16px !important;
          border: 1px solid #dee2e6 !important;
          border-radius: 8px !important;
          font-size: 14px !important;
          line-height: 1.8 !important;
          font-family: 'Courier New', Consolas, monospace !important;
          white-space: pre-wrap !important;
          word-break: break-word !important;
        `;
        
        console.log('Pre tag #' + (index + 1) + ':', pre.textContent.length + ' characters');
      });
      
      // Apply dark mode styles if needed
      if (document.body.classList.contains('dark-mode')) {
        allPre.forEach(function(pre) {
          pre.style.color = '#ffffff';
          pre.style.background = '#2d3748';
          pre.style.borderColor = '#4a5568';
        });
      }
      
      console.log('‚úÖ Text forced visible for', allPre.length, 'pre tags');
    }, 150);
  });



    // ==================== DEVICE DETECTION ====================
    function detectBrowser() {
      const userAgent = navigator.userAgent;
      const browsers = [
        { name: 'Microsoft Edge', test: /Edg/, versionRegex: /Edg\/([0-9.]+)/ },
        { name: 'Mozilla Firefox', test: /Firefox/, versionRegex: /Firefox\/([0-9.]+)/ },
        { name: 'Google Chrome', test: /Chrome(?!.*Edg)/, versionRegex: /Chrome\/([0-9.]+)/ },
        { name: 'Safari', test: /Safari(?!.*Chrome)/, versionRegex: /Version\/([0-9.]+)/ }
      ];
      
      const getVersion = (regex) => {
        const match = userAgent.match(regex);
        return match ? match[1] : 'Unknown';
      };
      
      const detectOS = () => {
        if (/Win/.test(userAgent)) return { name: 'Windows', version: (userAgent.match(/Windows NT ([0-9.]+)/) || [])[1] || 'Unknown' };
        if (/Mac/.test(userAgent)) return { name: 'MacOS', version: (userAgent.match(/Mac OS X ([0-9._]+)/) || [])[1]?.replace(/_/g, '.') || 'Unknown' };
        if (/Linux/.test(userAgent)) return { name: 'Linux', version: 'Unknown' };
        return { name: 'Unknown', version: 'Unknown' };
      };
      
      const detectDeviceType = () => {
        if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(userAgent)) return 'mobile';
        if (/Tablet|iPad/i.test(userAgent)) return 'tablet';
        return 'desktop';
      };
      
      for (const browser of browsers) {
        if (browser.test.test(userAgent)) {
          return {
            name: browser.name,
            version: getVersion(browser.versionRegex),
            os: detectOS(),
            deviceType: detectDeviceType()
          };
        }
      }
      
      return {
        name: 'Unknown',
        version: 'Unknown',
        os: detectOS(),
        deviceType: detectDeviceType()
      };
    }

    function generateDeviceFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('fingerprint', 2, 2);
      const canvasData = canvas.toDataURL();
      
      const fingerprint = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: canvasData.slice(0, 50),
        platform: navigator.platform
      };
      
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }

    // ==================== GLOBAL VARIABLES ====================
    const browserInfo = detectBrowser();
    const API_BASE = '/api';
    let currentDeviceId = null;
    let currentParticipantId = null;
    let currentSessionNumber = 1;
    let typingStartTime = null;
    let totalCharactersTyped = 0;
    let unlockedPersons = [1];

    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingEnabled = false;
    let recordingStartPerf = 0;
    const keyEvents = [];
    let sessionMetadata = {};
    const MIN_SLICE_BYTES = 1200;
    const PRE_MS = 60;
    const POST_MS = 200;

    let statusEl, keyListEl, inputArea, startBtn, stopBtn, consentChk, clearBtn;
    let pidEl, sessionEl, genderEl, handEl, personEl;
    let deviceIdDisplay, osDisplay, browserDisplay, deviceTypeDisplay, sessionInfo;

    // ==================== INITIALIZATION ====================
    document.addEventListener('DOMContentLoaded', async () => {
      statusEl = document.getElementById('status');
      keyListEl = document.getElementById('keyList');
      inputArea = document.getElementById('inputArea');
      startBtn = document.getElementById('startBtn');
      stopBtn = document.getElementById('stopBtn');
      clearBtn = document.getElementById('clearBtn');
      consentChk = document.getElementById('consentChk');
      pidEl = document.getElementById('pid');
      sessionEl = document.getElementById('session');
      genderEl = document.getElementById('gender');
      handEl = document.getElementById('hand');
      personEl = document.getElementById('person');
      deviceIdDisplay = document.getElementById('deviceIdDisplay');
      osDisplay = document.getElementById('osDisplay');
      browserDisplay = document.getElementById('browserDisplay');
      deviceTypeDisplay = document.getElementById('deviceTypeDisplay');
      sessionInfo = document.getElementById('sessionInfo');

      osDisplay.value = `${browserInfo.os.name} ${browserInfo.os.version}`;
      browserDisplay.value = `${browserInfo.name} ${browserInfo.version}`;
      deviceTypeDisplay.value = browserInfo.deviceType.charAt(0).toUpperCase() + browserInfo.deviceType.slice(1);

      console.log('Initializing application...');
      await registerDevice();
      await getNextParticipantId();

      startBtn.addEventListener('click', handleStart);
      stopBtn.addEventListener('click', handleStop);
      clearBtn.addEventListener('click', handleClear);
      inputArea.addEventListener('keydown', handleKeydown);
    });

    // ==================== DEVICE REGISTRATION ====================
    async function registerDevice() {
      const fingerprint = generateDeviceFingerprint();
      
      try {
        statusEl.innerText = 'Registering device...';
        console.log('Calling register-device API with fingerprint:', fingerprint);
        
        const response = await fetch(`${API_BASE}/register-device`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            deviceFingerprint: fingerprint, 
            browserInfo,
            osInfo: browserInfo.os 
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Register device failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Register device response:', data);
        
        if (!data.deviceId) {
          throw new Error('No deviceId in response');
        }
        
        currentDeviceId = data.deviceId;
        deviceIdDisplay.value = currentDeviceId;
        statusEl.innerText = `Device registered: ${currentDeviceId}`;
        console.log('Device registered successfully:', currentDeviceId);
      } catch (err) {
        console.error('Device registration error:', err);
        statusEl.innerText = `Registration failed: ${err.message}. Check console (F12).`;
        alert('Device registration failed. Please check console (F12) for errors.');
      }
    }

    // ==================== PARTICIPANT ID GENERATION ====================


    async function getNextParticipantId() {
      if (!currentDeviceId) {
        console.error('Cannot get participant ID: no device ID');
        statusEl.innerText = 'Error: Device not registered';
        return;
      }
      
      try {
        statusEl.innerText = 'Getting participant ID...';
        console.log('Calling get-next-id API for device:', currentDeviceId);
        
        const response = await fetch(`${API_BASE}/get-next-id`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId: currentDeviceId })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Get ID failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Get ID response:', data);
        
        if (!data.participantId) {
          throw new Error('No participantId in response');
        }
        
        currentParticipantId = data.participantId;
        window.personsData = data.personsData; // Store globally
        currentSessionNumber = data.personsData['1'].nextSession; // Start with Person 1's next session

        unlockedPersons = data.unlockedPersons || [1]; // GET UNLOCKED PERSONS FROM API
        
        pidEl.value = currentParticipantId;
        sessionEl.value = currentSessionNumber;
        sessionInfo.innerText = `Next session for Person 1`;

        
        // UPDATE PERSON DROPDOWN BASED ON UNLOCKED PERSONS
        updatePersonDropdown();
        
        statusEl.innerText = `Ready! ${currentParticipantId}, Session ${currentSessionNumber}`;
        console.log('Setup complete:', { 
          currentParticipantId, 
          currentSessionNumber, 
          unlockedPersons,
          personsData: data.personsData
        });

        // Update session number when person dropdown changes
        personEl.addEventListener('change', function() {
          const selectedPerson = personEl.value;
          console.log('üîÑ Person changed to:', selectedPerson);
          console.log('üìä All persons data:', window.personsData);
          
          if (window.personsData && window.personsData[selectedPerson]) {
            const personData = window.personsData[selectedPerson];
            console.log(`üìä Person ${selectedPerson} data:`, personData);
            
            currentSessionNumber = personData.nextSession;
            sessionEl.value = currentSessionNumber;
            sessionInfo.textContent = `Next session for Person ${selectedPerson}`;
            
            console.log(`‚úÖ Session updated to: ${currentSessionNumber}`);
          } else {
            console.error('‚ùå Person data not found for:', selectedPerson);
          }
        });

        

      } catch (err) {
        console.error('Get participant ID error:', err);
        statusEl.innerText = `ID generation failed: ${err.message}. Check console.`;
        alert('Participant ID generation failed. Check console (F12) for details.');
      }
    }  // <-- This closes getNextParticipantId function

    // Update session number when person dropdown changes
// Update session number when person dropdown changes



    // New function to update person dropdown
    // New function to update person dropdown based on unlocked persons
    function updatePersonDropdown() {
      const allOptions = personEl.querySelectorAll('option');
      
      allOptions.forEach(option => {
        const personNum = parseInt(option.value);
        
        if (unlockedPersons.includes(personNum)) {
          // Person is unlocked
          option.disabled = false;
          option.style.color = '';
          option.textContent = `Person ${personNum}`;
        } else {
          // Person is locked
          option.disabled = true;
          option.style.color = '#999';
          option.textContent = `Person ${personNum} üîí (Complete Person ${personNum - 1} first)`;
        }
      });
      
      // Set to first unlocked person if current selection is locked
      const currentPerson = parseInt(personEl.value);
      if (!unlockedPersons.includes(currentPerson)) {
        personEl.value = String(unlockedPersons[0]);
      }
      
      console.log('Person dropdown updated. Unlocked:', unlockedPersons);
    }


    // ==================== TYPING SPEED CALCULATION ====================
    function calculateTypingSpeed() {
      if (!typingStartTime || totalCharactersTyped === 0) return { wpm: 0, category: 'Beginner' };
      
      const durationMinutes = (Date.now() - typingStartTime) / 60000;
      const words = totalCharactersTyped / 5;
      const wpm = Math.round(words / durationMinutes);
      
      let category = 'Beginner';
      if (wpm >= 60) category = 'Expert';
      else if (wpm >= 40) category = 'Intermediate';
      
      return { wpm, category };
    }

    // ==================== MICROPHONE INITIALIZATION ====================
    async function initMic() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        statusEl.innerText = 'Microphone granted.';
      } catch (err) {
        statusEl.innerText = 'Microphone denied: ' + err.name;
        console.error(err);
      }
    }

    // ==================== VALIDATION ====================
    function allMetaProvided() {
      return consentChk.checked && genderEl.value && handEl.value && currentParticipantId;
    }

    // ==================== EVENT HANDLERS ====================
    async function handleStart() {
      if (!currentParticipantId) {
        alert('Please wait for participant ID to load');
        return;
      }
      
      if (!allMetaProvided()) {
        alert('Please tick consent and select Gender and Handedness.');
        return;
      }
      
      if (!stream) await initMic();
      if (!stream) return;

      typingStartTime = Date.now();
      totalCharactersTyped = 0;

      sessionMetadata = {
        participant: {
          id: currentParticipantId,
          session: currentSessionNumber,
          person: personEl.value,
          gender: genderEl.value,
          handedness: handEl.value
        },
        device: {
          deviceId: currentDeviceId,
          browser: browserInfo.name,
          browserVersion: browserInfo.version,
          os: browserInfo.os.name,
          osVersion: browserInfo.os.version,
          deviceType: browserInfo.deviceType
        },
        start_time_utc: new Date().toISOString(),
        pre_ms: PRE_MS,
        post_ms: POST_MS
      };

      recordedChunks.length = 0;
      keyEvents.length = 0;

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size) recordedChunks.push(e.data);
      };
    mediaRecorder.onstop = async () => {
      console.log('Recording stopped.');
      
      const typingSpeed = calculateTypingSpeed();
      
      // Show forms IMMEDIATELY
      statusEl.innerText = 'Recording complete! Please fill the Google Forms below.';
      showFormsPrompt(typingSpeed);
      
      // Then process and upload
      statusEl.innerText = 'Processing and uploading...';
      await processRecordingAndCreateZip();
    };



      recordingStartPerf = performance.now();
      mediaRecorder.start();
      recordingEnabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      inputArea.disabled = false;
      inputArea.value = '';
      statusEl.innerText = 'üî¥ Recording... Start typing!';
      inputArea.focus();
    }

    function handleStop() {
      if (!mediaRecorder) return;
      recordingEnabled = false;
      try { mediaRecorder.stop(); } catch (e) {}
      startBtn.disabled = false;
      stopBtn.disabled = true;
      inputArea.disabled = true;
      statusEl.innerText = 'Stopping and processing...';
    }

    function handleClear() {
      inputArea.value = '';
      keyListEl.textContent = '';
      keyEvents.length = 0;
      totalCharactersTyped = 0;
    }

    function handleKeydown(event) {
      if (!recordingEnabled) return;
      if (['Shift','Control','Alt','Meta'].includes(event.key)) return;
      
      totalCharactersTyped++;
      
      const now = performance.now();
      const t_ms = now - recordingStartPerf;
      const keyLabel = event.key === ' ' ? 'space' : event.key;
      keyEvents.push({ key: keyLabel, t_ms });
      keyListEl.textContent = keyEvents.map(k=>k.key).slice(-30).join(', ');
    }

    // ==================== WAV ENCODING ====================
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function encodeWAVFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const buffer = new ArrayBuffer(44 + length * blockAlign);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * blockAlign, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    // ==================== UPLOAD TO GOOGLE DRIVE ====================
    async function uploadToGoogleDrive(zipBlob, metadata) {
      try {
        statusEl.innerText = 'Preparing upload...';
        console.log('File size:', (zipBlob.size / 1024 / 1024).toFixed(2), 'MB');

        const typingSpeed = calculateTypingSpeed();
        const selectedPerson = personEl.value;
        const zipFileName = `${currentParticipantId}_S${currentSessionNumber}_P${selectedPerson}_${genderEl.value}_${handEl.value}.zip`;

        // Get upload token from your API
        statusEl.innerText = 'Getting upload credentials...';
        const tokenResponse = await fetch(`${API_BASE}/get-upload-token`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!tokenResponse.ok) {
          throw new Error('Failed to get upload token');
        }

        const { access_token, rootFolderId } = await tokenResponse.json();

        // Helper function to ensure folder exists
        async function ensureFolder(parentId, folderName) {
          const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${folderName}'+and+'${parentId}'+in+parents+and+mimeType='application/vnd.google-apps.folder'+and+trashed=false&fields=files(id)`;
          const searchRes = await fetch(searchUrl, {
            headers: { 'Authorization': `Bearer ${access_token}` }
          });
          const searchData = await searchRes.json();
          
          if (searchData.files && searchData.files.length > 0) {
            return searchData.files[0].id;
          }
          
          // Create folder
          const createRes = await fetch('https://www.googleapis.com/drive/v3/files', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${access_token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              name: folderName,
              mimeType: 'application/vnd.google-apps.folder',
              parents: [parentId]
            })
          });
          
          const createData = await createRes.json();
          return createData.id;
        }

        // Create folder structure
        statusEl.innerText = 'Creating folder structure...';
        console.log('Creating folders...');
        
        const participantFolderId = await ensureFolder(rootFolderId, currentParticipantId);
        const personFolderId = await ensureFolder(participantFolderId, `Person_${selectedPerson}`);
        const sessionFolderId = await ensureFolder(personFolderId, `Session_${currentSessionNumber}`);
        
        console.log('Folder structure created');

        // Upload file directly to Google Drive using resumable upload
        statusEl.innerText = 'Uploading to Google Drive...';
        console.log('Starting resumable upload...');

        // Step 1: Initialize resumable upload
        const metadata = {
          name: zipFileName,
          parents: [sessionFolderId],
          mimeType: 'application/zip'
        };

        const initResponse = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=resumable', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${access_token}`,
            'Content-Type': 'application/json; charset=UTF-8',
            'X-Upload-Content-Type': 'application/zip',
            'X-Upload-Content-Length': zipBlob.size
          },
          body: JSON.stringify(metadata)
        });

        if (!initResponse.ok) {
          const errorText = await initResponse.text();
          throw new Error(`Failed to initialize upload: ${errorText}`);
        }

        const uploadUrl = initResponse.headers.get('Location');
        console.log('Upload session created');

        // Step 2: Upload the file
        const uploadResponse = await fetch(uploadUrl, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/zip'
          },
          body: zipBlob
        });

        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          throw new Error(`Upload failed: ${errorText}`);
        }

        const uploadResult = await uploadResponse.json();
        console.log('‚úÖ Upload successful! File ID:', uploadResult.id);

        // Update CSV
        statusEl.innerText = 'Updating CSV...';

        const csvData = {
          deviceId: currentDeviceId,
          participantId: currentParticipantId,
          session: currentSessionNumber,
          person: selectedPerson,
          gender: genderEl.value,
          handedness: handEl.value,
          totalKeys: keyEvents.length,
          browserInfo: browserInfo,
          osInfo: browserInfo.os,
          typingSpeed: typingSpeed.wpm,
          typingCategory: typingSpeed.category
        };

        const csvResponse = await fetch(`${API_BASE}/update-csv`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(csvData)
        });

        if (csvResponse.ok) {
          console.log('CSV updated successfully');
        }

        // UPDATE COUNTER.JSON
        statusEl.innerText = 'Updating session counter...';
        const counterResponse = await fetch(`${API_BASE}/update-counter`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            person: selectedPerson
          })
        });

        if (counterResponse.ok) {
          const counterResult = await counterResponse.json();
          console.log('‚úÖ Counter updated:', counterResult);
        } else {
          console.error('Counter update failed');
        }

        const folderPath = `${currentParticipantId}/Person_${selectedPerson}/Session_${currentSessionNumber}`;
        statusEl.innerText = `‚úÖ COMPLETED! WPM: ${typingSpeed.wpm} (${typingSpeed.category}) | Uploaded to ${folderPath}`;
        inputArea.value = '';

        // Reload participant data NOW that upload is complete
        console.log('üîÑ Reloading participant data after successful upload...');
        try {
          await getNextParticipantId();
          console.log('‚úÖ Data reloaded - sessions and persons updated!');
        } catch (err) {
          console.error('Error reloading data:', err);
        }

        showFormsPrompt(typingSpeed);

        
      } catch (err) {
        console.error('Upload error:', err);
        statusEl.innerText = `‚ùå Upload failed: ${err.message}`;
        alert('Upload failed: ' + err.message + '\nCheck console (F12) for details.');
      }
    }




    // ==================== SHOW FORMS PROMPT ====================
    function showFormsPrompt(typingSpeed) {
      const existingPrompt = document.getElementById('formsPrompt');
      if (existingPrompt) existingPrompt.remove();
      
      const formsHTML = `
        <div id="formsPrompt" style="margin-top: 24px; padding: 24px; background: #f0f9ff; border: 2px solid #0369a1; border-radius: 12px; animation: slideIn 0.3s ease-out;">
          <h3 style="margin-top: 0; color: #0369a1; font-size: 1.4em;">üéâ Recording Complete!</h3>
          <div style="background: white; padding: 16px; border-radius: 8px; margin: 16px 0;">
            <p style="margin: 4px 0;"><strong>Participant ID:</strong> ${currentParticipantId}</p>
            <p style="margin: 4px 0;"><strong>Session:</strong> ${currentSessionNumber}</p>
            <p style="margin: 4px 0;"><strong>Person:</strong> ${personEl.value}</p>
            <p style="margin: 4px 0;"><strong>Typing Speed:</strong> ${typingSpeed.wpm} WPM (${typingSpeed.category})</p>
            <p style="margin: 4px 0;"><strong>Keys Recorded:</strong> ${keyEvents.length}</p>
          </div>
          <p style="margin-top: 20px; font-weight: 600; font-size: 1.1em; color: #0c4a6e;">üìã Please complete these research forms:</p>
          <p style="margin-bottom: 16px; color: #555; font-size: 0.95em;">Your feedback is valuable for our research. Each form takes about 2-3 minutes.</p>
          <div style="display: flex; gap: 12px; margin-top: 16px; flex-wrap: wrap;">
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSewQ-ZdYvG7QtxooKVKzcr12ag4PylnmRQR5kZo5qRzbIycfQ/viewform" 
              target="_blank" 
              class="form-link-btn"
              style="flex: 1; min-width: 200px; display: inline-block; padding: 14px 20px; background: #4a90e2; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; text-align: center; transition: all 0.2s;">
              üìù Form 1: Background Information
            </a>
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSc_zpIaQNj3zUEvylUjD4bvMnSiGveKSTtRV7uaBceEr97hyA/viewform" 
              target="_blank" 
              class="form-link-btn"
              style="flex: 1; min-width: 200px; display: inline-block; padding: 14px 20px; background: #4a90e2; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; text-align: center; transition: all 0.2s;">
              üìù Form 2: User's Understanding 
            </a>
          </div>
          <p style="margin-top: 16px; font-size: 0.9em; color: #666; text-align: center;">‚úì Forms will open in new tabs</p>
          <p style="margin-top: 12px; font-size: 0.9em; color: #0369a1; text-align: center; font-weight: 600;">
            üí° Tip: Reload this page to continue with the next person!
          </p>
        </div>
      `;
      
      const pressedKeysDiv = document.querySelector('.pressed-keys');
      pressedKeysDiv.insertAdjacentHTML('afterend', formsHTML);
      
      document.querySelectorAll('.form-link-btn').forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          e.target.style.background = '#357ab8';
          e.target.style.transform = 'translateY(-2px)';
          e.target.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        });
        btn.addEventListener('mouseleave', (e) => {
          e.target.style.background = '#4a90e2';
          e.target.style.transform = 'translateY(0)';
          e.target.style.boxShadow = 'none';
        });
      });
      
      setTimeout(() => {
        document.getElementById('formsPrompt').scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 300);
    }

    // ==================== PROCESS RECORDING & CREATE ZIP ====================
    async function processRecordingAndCreateZip() {
      try {
        if (recordedChunks.length === 0) {
          statusEl.innerText = 'No audio recorded.';
          return;
        }
        
        const wholeBlob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
        const arrayBuffer = await wholeBlob.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        
        const typingSpeed = calculateTypingSpeed();
        
        sessionMetadata.sample_rate = decoded.sampleRate;
        sessionMetadata.duration_s = decoded.duration;
        sessionMetadata.num_channels = decoded.numberOfChannels;
        sessionMetadata.keys = keyEvents.map(k => ({ key: k.key, t_ms: k.t_ms }));
        sessionMetadata.typing_speed = typingSpeed.wpm;
        sessionMetadata.typing_category = typingSpeed.category;
        sessionMetadata.generated_at = new Date().toISOString();
        sessionMetadata.total_events = keyEvents.length;

        const zip = new JSZip();
        const wholeExt = wholeBlob.type.includes('webm') ? 'webm' : 'ogg';
        zip.file(`continuous_audio.${wholeExt}`, wholeBlob);

        statusEl.innerText = `Processing ${keyEvents.length} keys...`;

        const filesMeta = [];
        for (let i = 0; i < keyEvents.length; i++) {
          const ev = keyEvents[i];
          const start_s = Math.max(0, (ev.t_ms - PRE_MS) / 1000);
          const end_s = Math.min(decoded.duration, (ev.t_ms + POST_MS) / 1000);
          const startSample = Math.floor(start_s * decoded.sampleRate);
          const endSample = Math.ceil(end_s * decoded.sampleRate);
          const sliceLength = endSample - startSample;
          
          if (sliceLength <= 0) continue;

          const numChannels = decoded.numberOfChannels;
          const sliceBuffer = audioCtx.createBuffer(numChannels, sliceLength, decoded.sampleRate);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = decoded.getChannelData(ch).subarray(startSample, endSample);
            sliceBuffer.copyToChannel(channelData, ch, 0);
          }

          const wavBlob = encodeWAVFromAudioBuffer(sliceBuffer);
          if (wavBlob.size < MIN_SLICE_BYTES) continue;

          const keySafe = String(ev.key).replace(/[^a-zA-Z0-9_-]/g, '') || 'key';
          const filename = `key_${String(i+1).padStart(4,'0')}_${keySafe}_${Math.round(ev.t_ms)}ms.wav`;

          zip.file(filename, wavBlob);
          filesMeta.push({ filename, key: ev.key, t_ms: ev.t_ms, size_bytes: wavBlob.size });
          
          if (i % 20 === 0 || i === keyEvents.length - 1) {
            statusEl.innerText = `Processing: ${i+1}/${keyEvents.length}`;
            await new Promise(r => setTimeout(r, 1));
          }
        }

        sessionMetadata.exported_files = filesMeta;
        zip.file('metadata.json', JSON.stringify(sessionMetadata, null, 2));

        statusEl.innerText = 'Creating ZIP file...';
        const zipBlob = await zip.generateAsync({ 
          type: 'blob', 
          compression: 'DEFLATE', 
          compressionOptions: { level: 6 } 
        }, (meta) => {
          statusEl.innerText = `Creating ZIP: ${Math.round(meta.percent)}%`;
        });

        console.log('ZIP created, size:', zipBlob.size);

        await uploadToGoogleDrive(zipBlob, sessionMetadata);

        const zipFilename = `${currentParticipantId}_S${currentSessionNumber}_P${personEl.value}_${genderEl.value}_${handEl.value}.zip`;
        triggerDownload(zipBlob, zipFilename);
      } catch (err) {
        console.error('Processing error:', err);
        statusEl.innerText = `Error: ${err.message}`;
        alert('Processing error: ' + err.message);
      }
    }

    // ==================== TRIGGER DOWNLOAD ====================
    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);



    }
  </script>
</body>
</html>
