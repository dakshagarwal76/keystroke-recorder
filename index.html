<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Keystroke Sound Recorder (WAV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-primary: #f5f7fa;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f8fafc;
      --bg-note: #fff7ed;
      --bg-badge: #e0f2fe;
      --text-primary: #222;
      --text-secondary: #555;
      --text-muted: #666;
      --text-badge: #0369a1;
      --text-note: #7c2d12;
      --border-color: #ddd;
      --border-light: #e5e7eb;
      --border-note: #fed7aa;
      --shadow: rgba(0, 0, 0, 0.08);
      --shadow-inset: rgba(0, 0, 0, 0.05);
      --input-disabled: #f0f0f0;
      --accent-primary: #4a90e2;
      --accent-hover: #357ab8;
      --btn-secondary: #6b7280;
      --btn-secondary-hover: #4b5563;
      --pre-bg: #f8fafc;
      --pre-text: #1f2937;
      --pre-border: #e5e7eb;
    }

    [data-theme="dark"] {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2d2d2d;
      --bg-tertiary: #242424;
      --bg-note: #2c1810;
      --bg-badge: #1e3a5f;
      --text-primary: #e5e5e5;
      --text-secondary: #b8b8b8;
      --text-muted: #999;
      --text-badge: #60a5fa;
      --text-note: #fbbf24;
      --border-color: #444;
      --border-light: #3a3a3a;
      --border-note: #92400e;
      --shadow: rgba(0, 0, 0, 0.3);
      --shadow-inset: rgba(0, 0, 0, 0.2);
      --input-disabled: #3a3a3a;
      --accent-primary: #5b9ef5;
      --accent-hover: #4a8dd8;
      --btn-secondary: #6b7280;
      --btn-secondary-hover: #9ca3af;
      --pre-bg: #242424;
      --pre-text: #e5e5e5;
      --pre-border: #3a3a3a;
    }

    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      display: flex;
      justify-content: center;
      align-items: start;
      min-height: 100vh;
      margin: 0;
      padding: 24px;
      color: var(--text-primary);
    }
    .container {
      background: var(--bg-secondary);
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 4px 20px var(--shadow);
      width: 100%;
      max-width: 900px;
      position: relative;
    }

    .theme-toggle {
      position: absolute;
      top: 24px;
      right: 24px;
      background: var(--accent-primary);
      border: none;
      border-radius: 50%;
      width: 45px;
      height: 45px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px var(--shadow);
      transition: all 0.3s ease;
      z-index: 10;
    }
    .theme-toggle:hover {
      background: var(--accent-hover);
      transform: scale(1.1);
    }
    .theme-toggle svg {
      width: 22px;
      height: 22px;
      fill: white;
    }

    h1 {
      font-size: 1.8em;
      color: var(--text-primary);
      margin: 0 0 6px 0;
      padding-right: 60px;
    }
    h2 {
      margin: 24px 0 8px;
      font-size: 1.2em;
      color: var(--text-primary);
    }
    p {
      font-size: 0.98em;
      color: var(--text-secondary);
      margin: 0 0 14px 0;
      line-height: 1.5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    label {
      font-size: 0.92em;
      color: var(--text-primary);
      display: block;
      margin-bottom: 6px;
    }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px;
      font-size: 1em;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      box-shadow: inset 0 1px 3px var(--shadow-inset);
      transition: all 0.2s;
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    input:disabled, select:disabled {
      background: var(--input-disabled);
      color: var(--text-muted);
      cursor: not-allowed;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
    }
    textarea {
      width: 100%;
      padding: 14px;
      font-size: 1.05em;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      resize: vertical;
      min-height: 160px;
      box-shadow: inset 0 1px 3px var(--shadow-inset);
      transition: all 0.2s;
      background: var(--bg-secondary);
      color: var(--text-primary);
    }
    .btn {
      background-color: var(--accent-primary);
      color: #000000;
      border: none;
      padding: 10px 18px;
      font-size: 0.98em;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .btn:hover { background-color: var(--accent-hover); }
    .btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .btn.secondary {
      background-color: var(--btn-secondary);
    }
    .btn.secondary:hover { background-color: var(--btn-secondary-hover); }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .muted {
      color: var(--text-muted);
      font-size: 0.9em;
    }
    .status {
      margin-top: 12px;
      font-size: 0.95em;
      color: var(--text-primary);
      min-height: 24px;
    }
    .pressed-keys {
      margin-top: 10px;
      font-size: 0.95em;
      color: var(--text-primary);
      word-wrap: break-word;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: var(--pre-bg);
      border: 1px solid var(--pre-border);
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
      color: var(--pre-text);
    }
    .consent {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 10px 0 4px;
    }
    .note {
      background: var(--bg-note);
      border: 1px solid var(--border-note);
      color: var(--text-note);
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 0.95em;
    }
    .info-badge {
      display: inline-block;
      background: var(--bg-badge);
      color: var(--text-badge);
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.9em;
      margin-top: 8px;
    }
    .sep { height: 1px; background: var(--border-light); margin: 18px 0; }

    footer {
      margin-top: 40px;
      padding-top: 12px;
      border-top: 1px solid var(--border-light);
      text-align: center;
      font-size: 0.9em;
      color: var(--text-secondary);
    }




  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <!-- Dark Mode Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
      <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z"/>
      </svg>
      <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;">
        <path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z"/>
      </svg>
    </button>

    <h1>Keystroke Sound Recorder</h1>
    <p class="muted">
      This page records short audio snippets around each key press while you type a standardized paragraph.
    </p>

    <div class="note">
      Grant microphone access when prompted. Keep your environment quiet to reduce background noise.
    </div>

    <h2>Device Information</h2>
    <div class="grid">
      <div>
        <label for="deviceIdDisplay">Device ID</label>
        <input id="deviceIdDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="osDisplay">Operating System</label>
        <input id="osDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="browserDisplay">Browser</label>
        <input id="browserDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="deviceTypeDisplay">Device Type</label>
        <input id="deviceTypeDisplay" type="text" readonly disabled />
      </div>
    </div>

    <h2>Participant Details</h2>
    <div class="grid">
      <div>
        <label for="pid">Participant ID</label>
        <input id="pid" type="text" readonly disabled />
      </div>
      <div>
        <label for="session">Session Number</label>
        <input id="session" type="number" min="1" value="1" readonly disabled />
        <span class="info-badge" id="sessionInfo">Auto-detected</span>
      </div>
      <div>
        <label for="person">Person</label>
        <select id="person">
          <option value="1">Person 1</option>
          <option value="2">Person 2</option>
          <option value="3">Person 3</option>
        </select>
      </div>
      <div>
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="">Select</option>
          <option>Female</option>
          <option>Male</option>
          <option>Other</option>
          <option>Prefer not to say</option>
        </select>
      </div>
      <div>
        <label for="hand">Handedness</label>
        <select id="hand">
          <option value="">Select</option>
          <option>Left</option>
          <option>Right</option>
          <option>Ambidextrous</option>
        </select>
      </div>
    </div>

    <div class="consent">
      <input type="checkbox" id="consentChk" />
      <label for="consentChk">I consent to participate in this research recording.</label>
    </div>

    <div class="sep"></div>

    <h2>Paragraph to Type</h2>
    <p class="muted">Type the paragraph below exactly as shown.</p>

    <pre>The quick brown fox jumps over the lazy dog while amazing zebras quietly vex jumpy kids, proving every letter is present. Pack my box with five dozen liquor jugs to verify the alphabet twice.
Digits appear forward and backward: 1234567890 then 0987654321, followed by sequences like 2468, 13579, and 314159.
Now we add punctuation: . , ; : ? ! ' " - _ ( ) [ ] { } / \
Symbols and operators: @ # $ % ^ & * + = &lt; &gt; | ~
To include uppercase properly, acronyms like NASA, USA, UN, AI, ML, and HTML are written in full caps.
Typing speed and accuracy will be measured across every key, ensuring consistency of captured events.
Finally, we conclude with a mix: The year is 2025; version v1.0-beta includes features [alpha], {bravo}, and (charlie), all typed carefully for complete coverage of the QWERTY keyboard.</pre>

    <h2>Typing Box</h2>
    <textarea id="inputArea" rows="8" placeholder="Start typing after clicking 'Start Recording'" disabled></textarea>

    <div class="button-row">
      <button class="btn" id="startBtn">Start Recording</button>
      <button class="btn" id="stopBtn" disabled>Stop Recording</button>
    </div>

    <div class="status" id="status">Loading...</div>
    <div class="pressed-keys">
      <strong>Keys Pressed:</strong> <span id="keyList"></span>
    </div>

    <footer>
      Developed by <strong>Vikrant Vikram</strong> | For Research Purpose
    </footer>
  </div>

  <script>
    // Dark Mode Toggle Implementation
    (function initTheme() {
      const htmlElement = document.documentElement;
      const themeToggle = document.getElementById('themeToggle');
      const sunIcon = document.getElementById('sunIcon');
      const moonIcon = document.getElementById('moonIcon');

      // Check for saved theme preference or default to 'light'
      const currentTheme = localStorage.getItem('theme') || 'light';
      htmlElement.setAttribute('data-theme', currentTheme);
      updateIcons(currentTheme);

      function updateIcons(theme) {
        if (theme === 'dark') {
          sunIcon.style.display = 'none';
          moonIcon.style.display = 'block';
        } else {
          sunIcon.style.display = 'block';
          moonIcon.style.display = 'none';
        }
      }

      themeToggle.addEventListener('click', function() {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        htmlElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateIcons(newTheme);
      });
    })();

    // Device Detection
    function detectBrowser() {
      const userAgent = navigator.userAgent;
      const browsers = [
        { name: 'Microsoft Edge', test: /Edg/, versionRegex: /Edg\/([0-9.]+)/ },
        { name: 'Mozilla Firefox', test: /Firefox/, versionRegex: /Firefox\/([0-9.]+)/ },
        { name: 'Google Chrome', test: /Chrome(?!.*Edg)/, versionRegex: /Chrome\/([0-9.]+)/ },
        { name: 'Safari', test: /Safari(?!.*Chrome)/, versionRegex: /Version\/([0-9.]+)/ }
      ];
      
      const getVersion = (regex) => {
        const match = userAgent.match(regex);
        return match ? match[1] : 'Unknown';
      };

      const detectOS = () => {
        if (/Win/.test(userAgent)) return { name: 'Windows', version: (userAgent.match(/Windows NT ([0-9.]+)/) || [])[1] || 'Unknown' };
        if (/Mac/.test(userAgent)) return { name: 'MacOS', version: (userAgent.match(/Mac OS X ([0-9._]+)/) || [])[1]?.replace(/_/g, '.') || 'Unknown' };
        if (/Linux/.test(userAgent)) return { name: 'Linux', version: 'Unknown' };
        return { name: 'Unknown', version: 'Unknown' };
      };
      
      const detectDeviceType = () => {
        if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(userAgent)) return 'mobile';
        if (/Tablet|iPad/i.test(userAgent)) return 'tablet';
        return 'desktop';
      };
      
      for (const browser of browsers) {
        if (browser.test.test(userAgent)) {
          return {
            name: browser.name,
            version: getVersion(browser.versionRegex),
            os: detectOS(),
            deviceType: detectDeviceType()
          };
        }
      }
      
      return {
        name: 'Unknown',
        version: 'Unknown',
        os: detectOS(),
        deviceType: detectDeviceType()
      };
    }

    function generateDeviceFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('fingerprint', 2, 2);
      const canvasData = canvas.toDataURL();
      
      const fingerprint = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: canvasData.slice(0, 50),
        platform: navigator.platform
      };
      
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }

    const browserInfo = detectBrowser();
    const API_BASE = '/api';
    let currentDeviceId = null;
    let currentParticipantId = null;
    let currentSessionNumber = 1;
    let typingStartTime = null;
    let totalCharactersTyped = 0;

    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingEnabled = false;
    let recordingStartPerf = 0;
    const keyEvents = [];
    let sessionMetadata = {};
    const MIN_SLICE_BYTES = 1200;
    const PRE_MS = 60;
    const POST_MS = 200;

    let statusEl, keyListEl, inputArea, startBtn, stopBtn, consentChk;
    let pidEl, sessionEl, genderEl, handEl, personEl;
    let deviceIdDisplay, osDisplay, browserDisplay, deviceTypeDisplay, sessionInfo;

    document.addEventListener('DOMContentLoaded', async () => {
      statusEl = document.getElementById('status');
      keyListEl = document.getElementById('keyList');
      inputArea = document.getElementById('inputArea');
      startBtn = document.getElementById('startBtn');
      stopBtn = document.getElementById('stopBtn');
      consentChk = document.getElementById('consentChk');
      pidEl = document.getElementById('pid');
      sessionEl = document.getElementById('session');
      genderEl = document.getElementById('gender');
      handEl = document.getElementById('hand');
      personEl = document.getElementById('person');
      deviceIdDisplay = document.getElementById('deviceIdDisplay');
      osDisplay = document.getElementById('osDisplay');
      browserDisplay = document.getElementById('browserDisplay');
      deviceTypeDisplay = document.getElementById('deviceTypeDisplay');
      sessionInfo = document.getElementById('sessionInfo');

      osDisplay.value = `${browserInfo.os.name} ${browserInfo.os.version}`;
      browserDisplay.value = `${browserInfo.name} ${browserInfo.version}`;
      deviceTypeDisplay.value = browserInfo.deviceType.charAt(0).toUpperCase() + browserInfo.deviceType.slice(1);

      console.log('Initializing application...');
      await registerDevice();
      await getNextParticipantId();

      startBtn.addEventListener('click', handleStart);
      stopBtn.addEventListener('click', handleStop);
      inputArea.addEventListener('keydown', handleKeydown);
    });

    async function registerDevice() {
      const fingerprint = generateDeviceFingerprint();
      
      try {
        statusEl.innerText = 'Registering device...';
        console.log('Calling register-device API with fingerprint:', fingerprint);
        
        const response = await fetch(`${API_BASE}/register-device`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            deviceFingerprint: fingerprint, 
            browserInfo,
            osInfo: browserInfo.os 
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Register device failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Register device response:', data);
        
        if (!data.deviceId) {
          throw new Error('No deviceId in response');
        }
        
        currentDeviceId = data.deviceId;
        deviceIdDisplay.value = currentDeviceId;
        statusEl.innerText = `Device registered: ${currentDeviceId}`;
        console.log('Device registered successfully:', currentDeviceId);
      } catch (err) {
        console.error('Device registration error:', err);
        statusEl.innerText = `Registration failed: ${err.message}. Check console (F12).`;
        alert('Device registration failed. Please check:\n1. Environment variables in Vercel\n2. Service account permissions\n3. Console (F12) for errors');
      }
    }

    async function getNextParticipantId() {
      if (!currentDeviceId) {
        console.error('Cannot get participant ID: no device ID');
        statusEl.innerText = 'Error: Device not registered';
        return;
      }
      
      try {
        statusEl.innerText = 'Getting participant ID...';
        console.log('Calling get-next-id API for device:', currentDeviceId);
        
        const response = await fetch(`${API_BASE}/get-next-id`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId: currentDeviceId })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Get ID failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Get ID response:', data);
        
        if (!data.participantId) {
          throw new Error('No participantId in response');
        }
        
        currentParticipantId = data.participantId;
        currentSessionNumber = data.sessionNumber || 1;
        
        pidEl.value = currentParticipantId;
        sessionEl.value = currentSessionNumber;
        sessionInfo.innerText = `Session ${currentSessionNumber}`;
        statusEl.innerText = `Ready! ${currentParticipantId}, Session ${currentSessionNumber}`;
        console.log('Setup complete:', { currentParticipantId, currentSessionNumber });
      } catch (err) {
        console.error('Get participant ID error:', err);
        statusEl.innerText = `ID generation failed: ${err.message}. Check console.`;
        alert('Participant ID generation failed. Check console (F12) for details.');
      }
    }

    function calculateTypingSpeed() {
      if (!typingStartTime || totalCharactersTyped === 0) return { wpm: 0, category: 'Beginner' };
      
      const durationMinutes = (Date.now() - typingStartTime) / 60000;
      const words = totalCharactersTyped / 5;
      const wpm = Math.round(words / durationMinutes);
      
      let category = 'Beginner';
      if (wpm >= 60) category = 'Expert';
      else if (wpm >= 40) category = 'Intermediate';
      
      return { wpm, category };
    }

    async function initMic() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        statusEl.innerText = 'Microphone granted.';
      } catch (err) {
        statusEl.innerText = 'Microphone denied: ' + err.name;
        console.error(err);
      }
    }

    function allMetaProvided() {
      return consentChk.checked && genderEl.value && handEl.value && currentParticipantId;
    }

    async function handleStart() {
      if (!currentParticipantId) {
        alert('Please wait for participant ID to load');
        return;
      }
      
      if (!allMetaProvided()) {
        alert('Please tick consent and select Gender and Handedness.');
        return;
      }
      
      if (!stream) await initMic();
      if (!stream) return;

      typingStartTime = Date.now();
      totalCharactersTyped = 0;

      sessionMetadata = {
        participant: {
          id: currentParticipantId,
          session: currentSessionNumber,
          person: personEl.value,
          gender: genderEl.value,
          handedness: handEl.value
        },
        device: {
          deviceId: currentDeviceId,
          browser: browserInfo.name,
          browserVersion: browserInfo.version,
          os: browserInfo.os.name,
          osVersion: browserInfo.os.version,
          deviceType: browserInfo.deviceType
        },
        start_time_utc: new Date().toISOString(),
        pre_ms: PRE_MS,
        post_ms: POST_MS
      };

      recordedChunks.length = 0;
      keyEvents.length = 0;

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = async () => {
        statusEl.innerText = 'Processing recording...';
        await processRecordingAndCreateZip();
      };

      recordingStartPerf = performance.now();
      mediaRecorder.start();
      recordingEnabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      inputArea.disabled = false;
      inputArea.value = '';
      statusEl.innerText = 'ðŸ”´ Recording... Start typing!';
      inputArea.focus();
    }

    function handleStop() {
      if (!mediaRecorder) return;
      recordingEnabled = false;
      try { mediaRecorder.stop(); } catch (e) {}
      startBtn.disabled = false;
      stopBtn.disabled = true;
      inputArea.disabled = true;
      statusEl.innerText = 'Stopping and processing...';
    }

    function handleKeydown(event) {
      if (!recordingEnabled) return;
      if (['Shift','Control','Alt','Meta'].includes(event.key)) return;
      
      totalCharactersTyped++;
      
      const now = performance.now();
      const t_ms = now - recordingStartPerf;
      const keyLabel = event.key === ' ' ? 'space' : event.key;
      keyEvents.push({ key: keyLabel, t_ms });
      keyListEl.textContent = keyEvents.map(k=>k.key).slice(-30).join(', ');
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function encodeWAVFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const buffer = new ArrayBuffer(44 + length * blockAlign);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * blockAlign, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    async function uploadToGoogleDrive(zipBlob, metadata) {
      try {
        statusEl.innerText = 'Uploading to Google Drive...';
        console.log('Starting upload...');
        
        const reader = new FileReader();
        const base64Data = await new Promise((resolve, reject) => {
          reader.onloadend = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(zipBlob);
        });

        console.log('ZIP converted to base64, length:', base64Data.length);

        const typingSpeed = calculateTypingSpeed();
        console.log('Typing speed:', typingSpeed);
        
        const zipFileName = `${currentParticipantId}_S${currentSessionNumber}_${genderEl.value}_${handEl.value}.zip`;
        console.log('Uploading file:', zipFileName);
        
        const uploadResponse = await fetch(`${API_BASE}/upload-to-drive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            participantId: currentParticipantId,
            session: currentSessionNumber,
            gender: genderEl.value,
            handedness: handEl.value,
            zipData: base64Data,
            zipFileName
          })
        });
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          console.error('Upload failed:', errorText);
          throw new Error(`Upload failed: ${errorText}`);
        }
        
        const uploadResult = await uploadResponse.json();
        console.log('Upload successful:', uploadResult);
        
        if (!uploadResult.success) {
          throw new Error('Upload reported failure');
        }
        
        statusEl.innerText = 'Updating CSV...';
        
        const csvResponse = await fetch(`${API_BASE}/update-csv`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            deviceId: currentDeviceId,
            participantId: currentParticipantId,
            session: currentSessionNumber,
            person: personEl.value,
            gender: genderEl.value,
            handedness: handEl.value,
            totalKeys: keyEvents.length,
            browserInfo,
            osInfo: browserInfo.os,
            typingSpeed: typingSpeed.wpm,
            typingCategory: typingSpeed.category
          })
        });
        
        if (!csvResponse.ok) {
          console.error('CSV update failed');
        } else {
          console.log('CSV updated successfully');
        }
        
        statusEl.innerText = `âœ… COMPLETED! WPM: ${typingSpeed.wpm} (${typingSpeed.category}) | File uploaded successfully`;
        inputArea.value = '';
        
        setTimeout(() => {
          alert(`Recording complete!\n\nParticipant: ${currentParticipantId}\nSession: ${currentSessionNumber}\nTyping Speed: ${typingSpeed.wpm} WPM (${typingSpeed.category})\n\nFile uploaded to Google Drive!`);
        }, 500);
        
      } catch (err) {
        console.error('Upload process error:', err);
        statusEl.innerText = `âŒ Upload failed: ${err.message}. File saved locally.`;
      }
    }

    async function processRecordingAndCreateZip() {
      try {
        if (recordedChunks.length === 0) {
          statusEl.innerText = 'No audio recorded.';
          return;
        }
        
        const wholeBlob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
        const arrayBuffer = await wholeBlob.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        
        const typingSpeed = calculateTypingSpeed();
        
        sessionMetadata.sample_rate = decoded.sampleRate;
        sessionMetadata.duration_s = decoded.duration;
        sessionMetadata.num_channels = decoded.numberOfChannels;
        sessionMetadata.keys = keyEvents.map(k => ({ key: k.key, t_ms: k.t_ms }));
        sessionMetadata.typing_speed = typingSpeed.wpm;
        sessionMetadata.typing_category = typingSpeed.category;
        sessionMetadata.generated_at = new Date().toISOString();
        sessionMetadata.total_events = keyEvents.length;

        const zip = new JSZip();
        const wholeExt = wholeBlob.type.includes('webm') ? 'webm' : 'ogg';
        zip.file(`continuous_audio.${wholeExt}`, wholeBlob);

        statusEl.innerText = `Processing ${keyEvents.length} keys...`;

        const filesMeta = [];
        for (let i = 0; i < keyEvents.length; i++) {
          const ev = keyEvents[i];
          const start_s = Math.max(0, (ev.t_ms - PRE_MS) / 1000);
          const end_s = Math.min(decoded.duration, (ev.t_ms + POST_MS) / 1000);
          const startSample = Math.floor(start_s * decoded.sampleRate);
          const endSample = Math.ceil(end_s * decoded.sampleRate);
          const sliceLength = endSample - startSample;
          
          if (sliceLength <= 0) continue;

          const numChannels = decoded.numberOfChannels;
          const sliceBuffer = audioCtx.createBuffer(numChannels, sliceLength, decoded.sampleRate);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = decoded.getChannelData(ch).subarray(startSample, endSample);
            sliceBuffer.copyToChannel(channelData, ch, 0);
          }

          const wavBlob = encodeWAVFromAudioBuffer(sliceBuffer);
          if (wavBlob.size < MIN_SLICE_BYTES) continue;

          const keySafe = String(ev.key).replace(/[^a-zA-Z0-9_-]/g, '') || 'key';
          const filename = `key_${String(i+1).padStart(4,'0')}_${keySafe}_${Math.round(ev.t_ms)}ms.wav`;

          zip.file(filename, wavBlob);
          filesMeta.push({ filename, key: ev.key, t_ms: ev.t_ms, size_bytes: wavBlob.size });
          
          if (i % 20 === 0 || i === keyEvents.length - 1) {
            statusEl.innerText = `Processing: ${i+1}/${keyEvents.length}`;
            await new Promise(r => setTimeout(r, 1));
          }
        }

        sessionMetadata.exported_files = filesMeta;
        zip.file('metadata.json', JSON.stringify(sessionMetadata, null, 2));

        statusEl.innerText = 'Creating ZIP file...';
        const zipBlob = await zip.generateAsync({ 
          type: 'blob', 
          compression: 'DEFLATE', 
          compressionOptions: { level: 6 } 
        }, (meta) => {
          statusEl.innerText = `Creating ZIP: ${Math.round(meta.percent)}%`;
        });

        console.log('ZIP created, size:', zipBlob.size);

        await uploadToGoogleDrive(zipBlob, sessionMetadata);

        const zipFilename = `${currentParticipantId}_S${currentSessionNumber}_${genderEl.value}_${handEl.value}.zip`;
        triggerDownload(zipBlob, zipFilename);
      } catch (err) {
        console.error('Processing error:', err);
        statusEl.innerText = `Error: ${err.message}`;
        alert('Processing error: ' + err.message);
      }
    }

    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }
  </script>
</body>
</html>
