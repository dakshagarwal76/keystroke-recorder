<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Keystroke Sound Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f7fa;
      display: flex;
      justify-content: center;
      align-items: start;
      min-height: 100vh;
      margin: 0;
      padding: 24px;
      color: #222;
      transition: background 0.3s, color 0.3s;
    }
    body.dark-mode {
      background: #121212;
      color: #eee;
    }
    .container {
      background: #fff;
      padding: 32px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      width: 100%;
      max-width: 1000px;
    }
    body.dark-mode .container {
      background: #1e1e1e;
      color: #eee;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
    }

    /* Dark Mode Slider Switch */
    #darkModeSwitchContainer {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 16px;
    }
    .switch {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
    }
    .switch input[type="checkbox"] {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }
    .slider {
      position: relative;
      display: inline-block;
      width: 46px;
      height: 26px;
      background: #ccc;
      border-radius: 99px;
      transition: background 0.3s;
      vertical-align: middle;
    }
    .slider:before {
      content: "";
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      top: 3px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      transition: transform 0.3s, background 0.3s;
    }
    .switch input:checked + .slider {
      background: #4a90e2;
    }
    .switch input:checked + .slider:before {
      transform: translateX(20px);
      background: #fffde4;
    }
    .switch-label {
      display: inline-block;
      margin-left: 12px;
      font-size: 1em;
      color: #333;
      transition: color 0.3s;
    }
    body.dark-mode .switch-label {
      color: #f9fafb;
    }
    body.dark-mode .slider {
      background: #374151;
    }
    body.dark-mode .switch input:checked + .slider {
      background: #ffd600;
    }

    h1 {
      font-size: 2em;
      margin: 0 0 10px 0;
      font-weight: 600;
      color: #333;
    }
    body.dark-mode h1 {
      color: #eee;
    }
    h2 {
      margin: 32px 0 16px;
      font-size: 1.3em;
      color: #333;
      font-weight: 600;
    }
    body.dark-mode h2 {
      color: #eee;
    }
    p {
      font-size: 0.98em;
      color: #555;
      margin: 0 0 14px 0;
      line-height: 1.6;
    }
    body.dark-mode p {
      color: #ccc;
    }

    .device-grid,
    .participant-grid {
      display: grid;
      gap: 16px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .device-grid {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .participant-grid {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }

    label {
      font-size: 0.92em;
      color: #333;
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
    }
    body.dark-mode label {
      color: #ddd;
    }
    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      padding: 10px 12px;
      font-size: 1em;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: #fff;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
      transition: border-color 0.2s;
    }
    input:disabled,
    select:disabled {
      background: #f0f0f0;
      color: #666;
      cursor: not-allowed;
    }
    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #4a90e2;
    }
    body.dark-mode input,
    body.dark-mode select,
    body.dark-mode textarea {
      background: #2c2c2c;
      color: #eee;
      border-color: #555;
    }
    body.dark-mode input:disabled,
    body.dark-mode select:disabled {
      background: #444;
      color: #aaa;
    }
    textarea {
      width: 100%;
      padding: 14px;
      font-size: 1.05em;
      border: 2px solid #ddd;
      border-radius: 8px;
      resize: vertical;
      min-height: 160px;
      background: #fff;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
      transition: border-color 0.2s;
      font-family: 'Segoe UI', sans-serif;
    }
    textarea:disabled {
      background: #f0f0f0;
      color: #666;
    }
    body.dark-mode textarea {
      background: #2c2c2c;
      color: #eee;
    }
    body.dark-mode textarea:disabled {
      background: #444;
      color: #aaa;
    }

    .btn {
      background-color: #4a90e2;
      color: #fff;
      border: none;
      padding: 12px 20px;
      font-size: 1em;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      font-weight: 600;
    }
    .btn:hover {
      background-color: #357ab8;
      transform: translateY(-1px);
    }
    .btn:active {
      transform: translateY(0);
    }
    .btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    .btn.secondary {
      background-color: #6b7280;
    }
    .btn.secondary:hover {
      background-color: #4b5563;
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
      align-items: center;
    }
    body.dark-mode .btn {
      background-color: #357ab8;
    }
    body.dark-mode .btn:hover {
      background-color: #2563eb;
    }
    body.dark-mode .btn.secondary {
      background: #4b5563;
    }
    body.dark-mode .btn.secondary:hover {
      background: #374151;
    }

    .muted {
      color: #666;
      font-size: 0.9em;
    }
    body.dark-mode .muted {
      color: #999;
    }
    .status {
      margin-top: 16px;
      font-size: 1em;
      color: #444;
      min-height: 24px;
      font-weight: 500;
    }
    body.dark-mode .status {
      color: #ddd;
    }
    .pressed-keys {
      margin-top: 12px;
      font-size: 0.95em;
      color: #222;
      word-wrap: break-word;
    }
    body.dark-mode .pressed-keys {
      color: #ddd;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      font-family: ui-monospace, 'Courier New', monospace;
      font-size: 0.95em;
      color: #1f2937;
      line-height: 1.7;
      margin: 12px 0;
    }
    body.dark-mode pre {
      background: #2c2c2c;
      border-color: #555;
      color: #e0e0e0;
    }
    .consent {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 16px 0 8px;
    }
    .consent input[type="checkbox"] {
      transform: scale(1.2);
      cursor: pointer;
    }
    .consent label {
      margin-bottom: 0;
    }
    .note {
      background: #fff7ed;
      border: 1px solid #fed7aa;
      color: #7c2d12;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.95em;
      margin: 16px 0;
    }
    body.dark-mode .note {
      background: #3a2e1a;
      border-color: #6b5832;
      color: #f5deb3;
    }
    .info-badge {
      display: inline-block;
      background: #e0f2fe;
      color: #0369a1;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.9em;
      margin-top: 8px;
      font-weight: 500;
    }
    body.dark-mode .info-badge {
      background: #0c4a6e;
      color: #7dd3fc;
    }
    .sep {
      height: 1px;
      background: #e5e7eb;
      margin: 24px 0;
    }
    body.dark-mode .sep {
      background: #444;
    }
    footer {
      margin-top: 48px;
      padding-top: 16px;
      border-top: 1px solid #e5e7eb;
      text-align: center;
      font-size: 0.9em;
      color: #555;
    }
    body.dark-mode footer {
      border-top-color: #444;
      color: #999;
    }
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (max-width: 768px) {
      .participant-grid,
      .device-grid {
        grid-template-columns: 1fr;
      }
      .container {
        padding: 18px;
      }
      h1 {
        font-size: 1.45em;
      }
    }

  select option:disabled {
    color: #999;
    font-style: italic;
  }

  body.dark-mode select option:disabled {
    color: #666;
  }

  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <!-- Dark Mode Slider Switch -->
    <div id="darkModeSwitchContainer">
      <label class="switch">
        <input type="checkbox" id="darkModeToggle" />
        <span class="slider"></span>
        <span class="switch-label" id="darkModeSwitchLabel">üåô Dark Mode</span>
      </label>
    </div>

    <h1>Keystroke Sound Recorder</h1>
    <p class="muted">
      This application records audio snippets around each keystroke while you type a standardized paragraph for research purposes.
    </p>
    <div class="note">
      ‚ö†Ô∏è Grant microphone access when prompted. Keep your environment quiet to reduce background noise.
    </div>

    <h2>Device Information</h2>
    <div class="device-grid">
      <div>
        <label for="deviceIdDisplay">Device ID</label>
        <input id="deviceIdDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="osDisplay">Operating System</label>
        <input id="osDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="browserDisplay">Browser</label>
        <input id="browserDisplay" type="text" readonly disabled />
      </div>
      <div>
        <label for="deviceTypeDisplay">Device Type</label>
        <input id="deviceTypeDisplay" type="text" readonly disabled />
      </div>
    </div>

    <h2>Participant Details</h2>
    <div class="participant-grid">
      <div>
        <label for="pid">Participant ID</label>
        <input id="pid" type="text" readonly disabled />
      </div>
      <div>
        <label for="session">Session Number</label>
        <input id="session" type="number" min="1" value="1" readonly disabled />
        <span class="info-badge" id="sessionInfo">Session 1</span>
      </div>
      <div>
        <label for="person">Person</label>
        <select id="person">
          <option value="1">Person 1</option>
          <option value="2">Person 2</option>
          <option value="3">Person 3</option>
          <option value="4">Person 4</option>
          <option value="5">Person 5</option>
        </select>
      </div>
      <div>
        <label for="gender">Gender</label>
        <select id="gender">
          <option value="">Select</option>
          <option>Female</option>
          <option>Male</option>
          <option>Other</option>
          <option>Prefer not to say</option>
        </select>
      </div>
      <div>
        <label for="hand">Handedness</label>
        <select id="hand">
          <option value="">Select</option>
          <option>Left</option>
          <option>Right</option>
          <option>Ambidextrous</option>
        </select>
      </div>
    </div>
    <div class="consent">
      <input type="checkbox" id="consentChk" />
      <label for="consentChk">I consent to participate in this research recording.</label>
    </div>

    <div class="sep"></div>
    <h2>Paragraph to Type</h2>
    <p class="muted">Type the paragraph below exactly as shown.</p>
    <pre>The quick brown fox jumps over the lazy dog while amazing zebras quietly vex jumpy kids, proving every letter is present. Pack my box with five dozen liquor jugs to verify the alphabet twice.
Digits appear forward and backward: 1234567890 then 0987654321, followed by sequences like 2468, 13579, and 314159.
Now we add punctuation: . , ; : ? ! ' " - _ ( ) [ ] { } / \
Symbols and operators: @ # $ % ^ & * + = < > | ~
To include uppercase properly, acronyms like NASA, USA, UN, AI, ML, and HTML are written in full caps.
Typing speed and accuracy will be measured across every key, ensuring consistency of captured events.
Finally, we conclude with a mix: The year is 2025; version v1.0-beta includes features [alpha], {bravo}, and (charlie), all typed carefully for complete coverage of the QWERTY keyboard.</pre>

    <div class="sep"></div>
    <h2>Special Key Block</h2>
    <p class="muted">After finishing the paragraph, press each key exactly once in this order.</p>
    <pre>1) Tab
2) Backspace
3) Delete
4) Arrow Up
5) Arrow Down
6) Arrow Left
7) Arrow Right
8) Esc
9) F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12
10) Caps Lock (press once to enable, once to disable)
11) Enter (to confirm completion)</pre>

    <div class="sep"></div>
    <h2>Typing Box</h2>
    <p class="muted">Click inside and start typing after clicking 'Start Recording'.</p>
    <textarea id="inputArea" rows="8" placeholder="Start typing after clicking 'Start Recording'" disabled></textarea>
    <div class="button-row">
      <button class="btn" id="startBtn">Start Recording</button>
      <button class="btn" id="stopBtn" disabled>Stop Recording</button>
      <button class="btn secondary" id="clearBtn">Clear Box</button>
    </div>
    <div class="status" id="status">Loading...</div>
    <div class="pressed-keys">
      <strong>Keys Pressed:</strong> <span id="keyList"></span>
    </div>

    <footer>
       For Research Purposes
    </footer>
  </div>

  <script>
    // ==================== DARK MODE TOGGLE ====================
    const darkModeToggle = document.getElementById('darkModeToggle');
    const switchLabel = document.getElementById('darkModeSwitchLabel');
    
    if (localStorage.getItem('darkModeEnabled') === 'true') {
      document.body.classList.add('dark-mode');
      darkModeToggle.checked = true;
      switchLabel.textContent = '‚òÄÔ∏è Light Mode';
    } else {
      switchLabel.textContent = 'üåô Dark Mode';
    }
    
    darkModeToggle.addEventListener('change', () => {
      if (darkModeToggle.checked) {
        document.body.classList.add('dark-mode');
        localStorage.setItem('darkModeEnabled', 'true');
        switchLabel.textContent = '‚òÄÔ∏è Light Mode';
      } else {
        document.body.classList.remove('dark-mode');
        localStorage.setItem('darkModeEnabled', 'false');
        switchLabel.textContent = 'üåô Dark Mode';
      }
    });

    // ==================== DEVICE DETECTION ====================
    function detectBrowser() {
      const userAgent = navigator.userAgent;
      const browsers = [
        { name: 'Microsoft Edge', test: /Edg/, versionRegex: /Edg\/([0-9.]+)/ },
        { name: 'Mozilla Firefox', test: /Firefox/, versionRegex: /Firefox\/([0-9.]+)/ },
        { name: 'Google Chrome', test: /Chrome(?!.*Edg)/, versionRegex: /Chrome\/([0-9.]+)/ },
        { name: 'Safari', test: /Safari(?!.*Chrome)/, versionRegex: /Version\/([0-9.]+)/ }
      ];
      
      const getVersion = (regex) => {
        const match = userAgent.match(regex);
        return match ? match[1] : 'Unknown';
      };
      
      const detectOS = () => {
        if (/Win/.test(userAgent)) return { name: 'Windows', version: (userAgent.match(/Windows NT ([0-9.]+)/) || [])[1] || 'Unknown' };
        if (/Mac/.test(userAgent)) return { name: 'MacOS', version: (userAgent.match(/Mac OS X ([0-9._]+)/) || [])[1]?.replace(/_/g, '.') || 'Unknown' };
        if (/Linux/.test(userAgent)) return { name: 'Linux', version: 'Unknown' };
        return { name: 'Unknown', version: 'Unknown' };
      };
      
      const detectDeviceType = () => {
        if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(userAgent)) return 'mobile';
        if (/Tablet|iPad/i.test(userAgent)) return 'tablet';
        return 'desktop';
      };
      
      for (const browser of browsers) {
        if (browser.test.test(userAgent)) {
          return {
            name: browser.name,
            version: getVersion(browser.versionRegex),
            os: detectOS(),
            deviceType: detectDeviceType()
          };
        }
      }
      
      return {
        name: 'Unknown',
        version: 'Unknown',
        os: detectOS(),
        deviceType: detectDeviceType()
      };
    }

    function generateDeviceFingerprint() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('fingerprint', 2, 2);
      const canvasData = canvas.toDataURL();
      
      const fingerprint = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        screenResolution: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        canvas: canvasData.slice(0, 50),
        platform: navigator.platform
      };
      
      const str = JSON.stringify(fingerprint);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }

    // ==================== GLOBAL VARIABLES ====================
    const browserInfo = detectBrowser();
    const API_BASE = '/api';
    let currentDeviceId = null;
    let currentParticipantId = null;
    let currentSessionNumber = 1;
    let typingStartTime = null;
    let totalCharactersTyped = 0;
    let unlockedPersons = [1];

    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let recordingEnabled = false;
    let recordingStartPerf = 0;
    const keyEvents = [];
    let sessionMetadata = {};
    const MIN_SLICE_BYTES = 1200;
    const PRE_MS = 60;
    const POST_MS = 200;

    let statusEl, keyListEl, inputArea, startBtn, stopBtn, consentChk, clearBtn;
    let pidEl, sessionEl, genderEl, handEl, personEl;
    let deviceIdDisplay, osDisplay, browserDisplay, deviceTypeDisplay, sessionInfo;

    // ==================== INITIALIZATION ====================
    document.addEventListener('DOMContentLoaded', async () => {
      statusEl = document.getElementById('status');
      keyListEl = document.getElementById('keyList');
      inputArea = document.getElementById('inputArea');
      startBtn = document.getElementById('startBtn');
      stopBtn = document.getElementById('stopBtn');
      clearBtn = document.getElementById('clearBtn');
      consentChk = document.getElementById('consentChk');
      pidEl = document.getElementById('pid');
      sessionEl = document.getElementById('session');
      genderEl = document.getElementById('gender');
      handEl = document.getElementById('hand');
      personEl = document.getElementById('person');
      deviceIdDisplay = document.getElementById('deviceIdDisplay');
      osDisplay = document.getElementById('osDisplay');
      browserDisplay = document.getElementById('browserDisplay');
      deviceTypeDisplay = document.getElementById('deviceTypeDisplay');
      sessionInfo = document.getElementById('sessionInfo');

      osDisplay.value = `${browserInfo.os.name} ${browserInfo.os.version}`;
      browserDisplay.value = `${browserInfo.name} ${browserInfo.version}`;
      deviceTypeDisplay.value = browserInfo.deviceType.charAt(0).toUpperCase() + browserInfo.deviceType.slice(1);

      console.log('Initializing application...');
      await registerDevice();
      await getNextParticipantId();

      startBtn.addEventListener('click', handleStart);
      stopBtn.addEventListener('click', handleStop);
      clearBtn.addEventListener('click', handleClear);
      inputArea.addEventListener('keydown', handleKeydown);
    });

    // ==================== DEVICE REGISTRATION ====================
    async function registerDevice() {
      const fingerprint = generateDeviceFingerprint();
      
      try {
        statusEl.innerText = 'Registering device...';
        console.log('Calling register-device API with fingerprint:', fingerprint);
        
        const response = await fetch(`${API_BASE}/register-device`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            deviceFingerprint: fingerprint, 
            browserInfo,
            osInfo: browserInfo.os 
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Register device failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Register device response:', data);
        
        if (!data.deviceId) {
          throw new Error('No deviceId in response');
        }
        
        currentDeviceId = data.deviceId;
        deviceIdDisplay.value = currentDeviceId;
        statusEl.innerText = `Device registered: ${currentDeviceId}`;
        console.log('Device registered successfully:', currentDeviceId);
      } catch (err) {
        console.error('Device registration error:', err);
        statusEl.innerText = `Registration failed: ${err.message}. Check console (F12).`;
        alert('Device registration failed. Please check console (F12) for errors.');
      }
    }

    // ==================== PARTICIPANT ID GENERATION ====================


    async function getNextParticipantId() {
      if (!currentDeviceId) {
        console.error('Cannot get participant ID: no device ID');
        statusEl.innerText = 'Error: Device not registered';
        return;
      }
      
      try {
        statusEl.innerText = 'Getting participant ID...';
        console.log('Calling get-next-id API for device:', currentDeviceId);
        
        const response = await fetch(`${API_BASE}/get-next-id`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ deviceId: currentDeviceId })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Get ID failed:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Get ID response:', data);
        
        if (!data.participantId) {
          throw new Error('No participantId in response');
        }
        
        currentParticipantId = data.participantId;
        currentSessionNumber = data.sessionNumber || 1;
        unlockedPersons = data.unlockedPersons || [1]; // GET UNLOCKED PERSONS FROM API
        
        pidEl.value = currentParticipantId;
        sessionEl.value = currentSessionNumber;
        sessionInfo.innerText = `Session ${currentSessionNumber}`;
        
        // UPDATE PERSON DROPDOWN BASED ON UNLOCKED PERSONS
        updatePersonDropdown();
        
        statusEl.innerText = `Ready! ${currentParticipantId}, Session ${currentSessionNumber}`;
        console.log('Setup complete:', { 
          currentParticipantId, 
          currentSessionNumber, 
          unlockedPersons 
        });
      } catch (err) {
        console.error('Get participant ID error:', err);
        statusEl.innerText = `ID generation failed: ${err.message}. Check console.`;
        alert('Participant ID generation failed. Check console (F12) for details.');
      }
    }

    // New function to update person dropdown
    // New function to update person dropdown based on unlocked persons
    function updatePersonDropdown() {
      const allOptions = personEl.querySelectorAll('option');
      
      allOptions.forEach(option => {
        const personNum = parseInt(option.value);
        
        if (unlockedPersons.includes(personNum)) {
          // Person is unlocked
          option.disabled = false;
          option.style.color = '';
          option.textContent = `Person ${personNum}`;
        } else {
          // Person is locked
          option.disabled = true;
          option.style.color = '#999';
          option.textContent = `Person ${personNum} üîí (Complete Person ${personNum - 1} first)`;
        }
      });
      
      // Set to first unlocked person if current selection is locked
      const currentPerson = parseInt(personEl.value);
      if (!unlockedPersons.includes(currentPerson)) {
        personEl.value = String(unlockedPersons[0]);
      }
      
      console.log('Person dropdown updated. Unlocked:', unlockedPersons);
    }


    // ==================== TYPING SPEED CALCULATION ====================
    function calculateTypingSpeed() {
      if (!typingStartTime || totalCharactersTyped === 0) return { wpm: 0, category: 'Beginner' };
      
      const durationMinutes = (Date.now() - typingStartTime) / 60000;
      const words = totalCharactersTyped / 5;
      const wpm = Math.round(words / durationMinutes);
      
      let category = 'Beginner';
      if (wpm >= 60) category = 'Expert';
      else if (wpm >= 40) category = 'Intermediate';
      
      return { wpm, category };
    }

    // ==================== MICROPHONE INITIALIZATION ====================
    async function initMic() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        statusEl.innerText = 'Microphone granted.';
      } catch (err) {
        statusEl.innerText = 'Microphone denied: ' + err.name;
        console.error(err);
      }
    }

    // ==================== VALIDATION ====================
    function allMetaProvided() {
      return consentChk.checked && genderEl.value && handEl.value && currentParticipantId;
    }

    // ==================== EVENT HANDLERS ====================
    async function handleStart() {
      if (!currentParticipantId) {
        alert('Please wait for participant ID to load');
        return;
      }
      
      if (!allMetaProvided()) {
        alert('Please tick consent and select Gender and Handedness.');
        return;
      }
      
      if (!stream) await initMic();
      if (!stream) return;

      typingStartTime = Date.now();
      totalCharactersTyped = 0;

      sessionMetadata = {
        participant: {
          id: currentParticipantId,
          session: currentSessionNumber,
          person: personEl.value,
          gender: genderEl.value,
          handedness: handEl.value
        },
        device: {
          deviceId: currentDeviceId,
          browser: browserInfo.name,
          browserVersion: browserInfo.version,
          os: browserInfo.os.name,
          osVersion: browserInfo.os.version,
          deviceType: browserInfo.deviceType
        },
        start_time_utc: new Date().toISOString(),
        pre_ms: PRE_MS,
        post_ms: POST_MS
      };

      recordedChunks.length = 0;
      keyEvents.length = 0;

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = async () => {
        statusEl.innerText = 'Processing recording...';
        await processRecordingAndCreateZip();
      };

      recordingStartPerf = performance.now();
      mediaRecorder.start();
      recordingEnabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      inputArea.disabled = false;
      inputArea.value = '';
      statusEl.innerText = 'üî¥ Recording... Start typing!';
      inputArea.focus();
    }

    function handleStop() {
      if (!mediaRecorder) return;
      recordingEnabled = false;
      try { mediaRecorder.stop(); } catch (e) {}
      startBtn.disabled = false;
      stopBtn.disabled = true;
      inputArea.disabled = true;
      statusEl.innerText = 'Stopping and processing...';
    }

    function handleClear() {
      inputArea.value = '';
      keyListEl.textContent = '';
      keyEvents.length = 0;
      totalCharactersTyped = 0;
    }

    function handleKeydown(event) {
      if (!recordingEnabled) return;
      if (['Shift','Control','Alt','Meta'].includes(event.key)) return;
      
      totalCharactersTyped++;
      
      const now = performance.now();
      const t_ms = now - recordingStartPerf;
      const keyLabel = event.key === ' ' ? 'space' : event.key;
      keyEvents.push({ key: keyLabel, t_ms });
      keyListEl.textContent = keyEvents.map(k=>k.key).slice(-30).join(', ');
    }

    // ==================== WAV ENCODING ====================
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    function encodeWAVFromAudioBuffer(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const length = audioBuffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const buffer = new ArrayBuffer(44 + length * blockAlign);
      const view = new DataView(buffer);
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length * blockAlign, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let ch = 0; ch < numChannels; ch++) channelData.push(audioBuffer.getChannelData(ch));

      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channelData[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    // ==================== UPLOAD TO GOOGLE DRIVE ====================
    async function uploadToGoogleDrive(zipBlob, metadata) {
      try {
        statusEl.innerText = 'Uploading to Google Drive...';
        console.log('Starting upload...');
        
        const reader = new FileReader();
        const base64Data = await new Promise((resolve, reject) => {
          reader.onloadend = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(zipBlob);
        });

        console.log('ZIP converted to base64, length:', base64Data.length);

        const typingSpeed = calculateTypingSpeed();
        console.log('Typing speed:', typingSpeed);
        
        // Get selected person value
        const selectedPerson = personEl.value;
        
        const zipFileName = `${currentParticipantId}_S${currentSessionNumber}_P${selectedPerson}_${genderEl.value}_${handEl.value}.zip`;
        console.log('Uploading file:', zipFileName);
        
        // Prepare upload data - MAKE SURE ALL FIELDS ARE INCLUDED
        const uploadData = {
          deviceId: currentDeviceId,
          participantId: currentParticipantId,
          session: currentSessionNumber,
          person: selectedPerson,  // IMPORTANT: Make sure this is included
          gender: genderEl.value,
          handedness: handEl.value,
          zipData: base64Data,
          zipFileName: zipFileName
        };
        
        console.log('Upload data prepared:', {
          deviceId: uploadData.deviceId,
          participantId: uploadData.participantId,
          session: uploadData.session,
          person: uploadData.person,
          fileName: uploadData.zipFileName,
          dataSize: uploadData.zipData.length
        });
        
        const uploadResponse = await fetch(`${API_BASE}/upload-to-drive`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(uploadData)
        });
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          console.error('Upload failed:', errorText);
          throw new Error(`Upload failed: ${errorText}`);
        }
        
        const uploadResult = await uploadResponse.json();
        console.log('Upload successful:', uploadResult);
        
        if (!uploadResult.success) {
          throw new Error('Upload reported failure');
        }
        
        statusEl.innerText = 'Updating CSV...';
        
        // UPDATE CSV - Make sure to call this
        const csvData = {
          deviceId: currentDeviceId,
          participantId: currentParticipantId,
          session: currentSessionNumber,
          person: selectedPerson,
          gender: genderEl.value,
          handedness: handEl.value,
          totalKeys: keyEvents.length,
          browserInfo: browserInfo,
          osInfo: browserInfo.os,
          typingSpeed: typingSpeed.wpm,
          typingCategory: typingSpeed.category
        };
        
        console.log('Updating CSV with data:', csvData);
        
        const csvResponse = await fetch(`${API_BASE}/update-csv`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(csvData)
        });
        
        if (!csvResponse.ok) {
          const csvError = await csvResponse.text();
          console.error('CSV update failed:', csvError);
        } else {
          const csvResult = await csvResponse.json();
          console.log('CSV updated successfully:', csvResult);
        }
        
        statusEl.innerText = `‚úÖ COMPLETED! WPM: ${typingSpeed.wpm} (${typingSpeed.category}) | File uploaded successfully`;
        inputArea.value = '';
        
        // Show forms after successful upload
        showFormsPrompt(typingSpeed);
        
      } catch (err) {
        console.error('Upload process error:', err);
        statusEl.innerText = `‚ùå Upload failed: ${err.message}. File saved locally.`;
      }
    }

    // ==================== SHOW FORMS PROMPT ====================
    function showFormsPrompt(typingSpeed) {
      const existingPrompt = document.getElementById('formsPrompt');
      if (existingPrompt) existingPrompt.remove();
      
      const formsHTML = `
        <div id="formsPrompt" style="margin-top: 24px; padding: 24px; background: #f0f9ff; border: 2px solid #0369a1; border-radius: 12px; animation: slideIn 0.3s ease-out;">
          <h3 style="margin-top: 0; color: #0369a1; font-size: 1.4em;">üéâ Recording Complete!</h3>
          <div style="background: white; padding: 16px; border-radius: 8px; margin: 16px 0;">
            <p style="margin: 4px 0;"><strong>Participant ID:</strong> ${currentParticipantId}</p>
            <p style="margin: 4px 0;"><strong>Session:</strong> ${currentSessionNumber}</p>
            <p style="margin: 4px 0;"><strong>Person:</strong> ${personEl.value}</p>
            <p style="margin: 4px 0;"><strong>Typing Speed:</strong> ${typingSpeed.wpm} WPM (${typingSpeed.category})</p>
            <p style="margin: 4px 0;"><strong>Keys Recorded:</strong> ${keyEvents.length}</p>
          </div>
          <p style="margin-top: 20px; font-weight: 600; font-size: 1.1em; color: #0c4a6e;">üìã Please complete these research forms:</p>
          <p style="margin-bottom: 16px; color: #555; font-size: 0.95em;">Your feedback is valuable for our research. Each form takes about 2-3 minutes.</p>
          <div style="display: flex; gap: 12px; margin-top: 16px; flex-wrap: wrap;">
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSewQ-ZdYvG7QtxooKVKzcr12ag4PylnmRQR5kZo5qRzbIycfQ/viewform" 
              target="_blank" 
              class="form-link-btn"
              style="flex: 1; min-width: 200px; display: inline-block; padding: 14px 20px; background: #4a90e2; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; text-align: center; transition: all 0.2s;">
              üìù Form 1: Background Information
            </a>
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSc_zpIaQNj3zUEvylUjD4bvMnSiGveKSTtRV7uaBceEr97hyA/viewform" 
              target="_blank" 
              class="form-link-btn"
              style="flex: 1; min-width: 200px; display: inline-block; padding: 14px 20px; background: #4a90e2; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; text-align: center; transition: all 0.2s;">
              üìù Form 2: User's Understanding 
            </a>
          </div>
          <p style="margin-top: 16px; font-size: 0.9em; color: #666; text-align: center;">‚úì Forms will open in new tabs</p>
          <p style="margin-top: 12px; font-size: 0.9em; color: #0369a1; text-align: center; font-weight: 600;">
            üí° Tip: Reload this page to continue with the next person!
          </p>
        </div>
      `;
      
      const pressedKeysDiv = document.querySelector('.pressed-keys');
      pressedKeysDiv.insertAdjacentHTML('afterend', formsHTML);
      
      document.querySelectorAll('.form-link-btn').forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          e.target.style.background = '#357ab8';
          e.target.style.transform = 'translateY(-2px)';
          e.target.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        });
        btn.addEventListener('mouseleave', (e) => {
          e.target.style.background = '#4a90e2';
          e.target.style.transform = 'translateY(0)';
          e.target.style.boxShadow = 'none';
        });
      });
      
      setTimeout(() => {
        document.getElementById('formsPrompt').scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 300);
    }

    // ==================== PROCESS RECORDING & CREATE ZIP ====================
    async function processRecordingAndCreateZip() {
      try {
        if (recordedChunks.length === 0) {
          statusEl.innerText = 'No audio recorded.';
          return;
        }
        
        const wholeBlob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
        const arrayBuffer = await wholeBlob.arrayBuffer();
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const decoded = await audioCtx.decodeAudioData(arrayBuffer);
        
        const typingSpeed = calculateTypingSpeed();
        
        sessionMetadata.sample_rate = decoded.sampleRate;
        sessionMetadata.duration_s = decoded.duration;
        sessionMetadata.num_channels = decoded.numberOfChannels;
        sessionMetadata.keys = keyEvents.map(k => ({ key: k.key, t_ms: k.t_ms }));
        sessionMetadata.typing_speed = typingSpeed.wpm;
        sessionMetadata.typing_category = typingSpeed.category;
        sessionMetadata.generated_at = new Date().toISOString();
        sessionMetadata.total_events = keyEvents.length;

        const zip = new JSZip();
        const wholeExt = wholeBlob.type.includes('webm') ? 'webm' : 'ogg';
        zip.file(`continuous_audio.${wholeExt}`, wholeBlob);

        statusEl.innerText = `Processing ${keyEvents.length} keys...`;

        const filesMeta = [];
        for (let i = 0; i < keyEvents.length; i++) {
          const ev = keyEvents[i];
          const start_s = Math.max(0, (ev.t_ms - PRE_MS) / 1000);
          const end_s = Math.min(decoded.duration, (ev.t_ms + POST_MS) / 1000);
          const startSample = Math.floor(start_s * decoded.sampleRate);
          const endSample = Math.ceil(end_s * decoded.sampleRate);
          const sliceLength = endSample - startSample;
          
          if (sliceLength <= 0) continue;

          const numChannels = decoded.numberOfChannels;
          const sliceBuffer = audioCtx.createBuffer(numChannels, sliceLength, decoded.sampleRate);
          for (let ch = 0; ch < numChannels; ch++) {
            const channelData = decoded.getChannelData(ch).subarray(startSample, endSample);
            sliceBuffer.copyToChannel(channelData, ch, 0);
          }

          const wavBlob = encodeWAVFromAudioBuffer(sliceBuffer);
          if (wavBlob.size < MIN_SLICE_BYTES) continue;

          const keySafe = String(ev.key).replace(/[^a-zA-Z0-9_-]/g, '') || 'key';
          const filename = `key_${String(i+1).padStart(4,'0')}_${keySafe}_${Math.round(ev.t_ms)}ms.wav`;

          zip.file(filename, wavBlob);
          filesMeta.push({ filename, key: ev.key, t_ms: ev.t_ms, size_bytes: wavBlob.size });
          
          if (i % 20 === 0 || i === keyEvents.length - 1) {
            statusEl.innerText = `Processing: ${i+1}/${keyEvents.length}`;
            await new Promise(r => setTimeout(r, 1));
          }
        }

        sessionMetadata.exported_files = filesMeta;
        zip.file('metadata.json', JSON.stringify(sessionMetadata, null, 2));

        statusEl.innerText = 'Creating ZIP file...';
        const zipBlob = await zip.generateAsync({ 
          type: 'blob', 
          compression: 'DEFLATE', 
          compressionOptions: { level: 6 } 
        }, (meta) => {
          statusEl.innerText = `Creating ZIP: ${Math.round(meta.percent)}%`;
        });

        console.log('ZIP created, size:', zipBlob.size);

        await uploadToGoogleDrive(zipBlob, sessionMetadata);

        const zipFilename = `${currentParticipantId}_S${currentSessionNumber}_P${personEl.value}_${genderEl.value}_${handEl.value}.zip`;
        triggerDownload(zipBlob, zipFilename);
      } catch (err) {
        console.error('Processing error:', err);
        statusEl.innerText = `Error: ${err.message}`;
        alert('Processing error: ' + err.message);
      }
    }

    // ==================== TRIGGER DOWNLOAD ====================
    function triggerDownload(blob, filename) {
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }
  </script>
</body>
</html>
